# <center>虚拟机执行子系统</center>
   代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，确实编程语言发展的一大步。  

> **编译型语言**
>
> 1. 类C语言
>     * 编译时将源代码编译成本地机器码
>     * 编译时进行连接
> 2. 类java语言
>     * 编译时将源代码编译成字节码
>     * 类型的加载、连接和初始化过程都是在程序运行期间完成的
>         > 缺点：类加载时会稍微增加一些性能开销
>         > 优点：为Java应用程序提供高度的灵活性（动态扩展的语言特性）  

**虚拟机的类加载机制**
   虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型

***

## 类加载的时机

   生命周期：加载、验证、准备、解析、初始化、使用和卸载七个阶段

   连接：验证、准备和解析

   类的生命周期图：
   ![类的生命周期](D:\local\notes\images\lifecircle.png)  

   类的加载过程的开始顺序：加载、验证、准备、初始化和卸载
   解析阶段在某些情况下可以在初始化阶段之后开始（Java的运行时绑定，也称动态绑定或晚期绑定）
   这些阶段通常是互相交叉地混合式进行，通常会在一个阶段执行过程中调用、激活另外一个阶段
***
   > **加载时机和初始化时机**
   > 1. 加载时机
   >     与虚拟机的具体实现相关（Java虚拟机规范没有强制约束）
   > 2. 初始化时机
   >     * 遇到字节码指令new、getstatic、putstatic或invokestatic，如果类没有初始化，则需要先触发其初始化
   >         > new: 使用new关键字实例化对象，创建数组时不会触发类初始化，但会触发对应数组类的初始化（字节码指令newarray，由虚拟机自动生成、直接继承java.lang.Object）
   >         > getstatic、putstatic: 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外，常量传播优化），只有直接定义这个字段的类被初始化，通过子类来引用父类中定义的静态字段，只会触发父类初始化而不会触发子类初始化
   >         > invokestatic: 调用一个类的静态方法
   >     * 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
   >     * 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
   >     * 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化主类
   >     * JDK7,如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic、REF_putstatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化
   > 这五种场景的行为被称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发初始化，称为被动引用
***
**接口**
   编译器会为接口生成<clinit>()类构造器，用于初始化接口中定义的成员变量
   接口加载过程与类加载过程稍有不同，接口初始化时，并不要求其父接口全部都完成初始化
## 类的加载过程
### 加载
#### 非数组类的加载过程
   1. 通过一个类的全限定名获取定义此类的二进制字节流（二进制字节流来源：Class文件、ZIP包、网络、运行时计算生成，由其他文件生成和从数据库读取等等），相较于其他阶段此阶段开发人员可控性最强（非数组类的加载阶段）
   2. 将这个字节流代表的静态数据结构转化为方法区运行时数据结构（存储格式由虚拟机实现自行定义）
   3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口（没有明确规定存放在Java堆中，对于HotSpot虚拟，Class对象比较特殊，存放在方法区）
#### 数组类的记载过程
   数组类不同过类加载器创建，而是由Java虚拟机直接创建
   1. 数组的组件类型（去掉一个维度的类型）是引用类型，则递归采用加载过程加载此组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识
   2. 数组的组件类型不是引用类型，Java虚拟机会把数组标记为与引导类加载器关联
      数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那么数组类的可见性默认为public
### 验证（非常重要、但不一定必要）
   目的：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
   Class文件来源：Java源代码编译，以及任何途径产生，甚至使用十六进制编辑器直接编写（字节码语言层面表达能力比Java更强）
   > Java语言本身相对安全
   > 1. 无法访问数组边界以外的数据
   > 2. 将一个对象类型转型为它并未实现的类型
   > 3. 跳转到不存在的代码行  

**验证阶段的虚拟机规范**
   一些Class文件格式中的静态和结构化约束（如果输入字节流步符合Class文件格式的约束，虚拟机应该抛出一个java.lang.VerifyError异常或其子类）
   1. 文件格式验证（验证字节流是否符合Class文件格式的规范，并且能被当前版本虚拟机处理），基于二进制字节流
       * 是否以魔数0xCAFEBABE开头
       * 主、次版本号是否在当前虚拟机处理范围之内
       * 常量池中的常量是否有不被支持的常量类型（检查常量tag标志）
       * 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
       * CONSTATNT_Utf8_info型的常量中是否有不符合UTF8编码的数据
       * Class文件中各个部分及文件本身是否有被删除的或附加的其他信息
   2. 元数据验证（语义分析，保证字节码描述的信息符合Java语言规范），对元数据信息中的数据类型进行校验，基于方法区存储结构
       * 这个类是否有父类（除了java.lang.Object）
       * 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
       * 如果这个类不是抽象类，是否实现了父类或接口之中要求实现的所有方法
       * 类中的字段、方法是否与父类产生矛盾（如覆盖了父类的final字段，或者出现不符合规则的方法重载，如方法参数一致，但返回值类型不同）
   3. 字节码验证（通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的），对类的方法体进行校验分析，保证被校验该类的方法在运行时不会做出危害虚拟机安全的事件，基于方法区存储结构（通过程序校验程序逻辑无法做到绝对准确-Halting Problem，最复杂的一个阶段）
      * 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
      * 保证跳转指令不会跳转到方法体以外的字节码指令
      * 保证方法体中的类型转换有效
      由于数据流验证的高复杂性，通过给方法体的Code属性的属性表中增加了一项名为StackMapTable属性进行优化（JDK6之后的Javac编译器和Java虚拟机）
      StackMapTable：描述了方法体中所有基本块（按控制流拆分的代码块）开始时的本地变量表和操作栈应有的状态（类型推导转变为类型检查）
   4. 符号引用验证（发生在虚拟机将符号引用转化为直接引用时-解析阶段发生，可以看做是对类自身以外的信息-常量池中各种符号引用进行匹配性校验），确保解析动作正常执行，如果无法通过符号引用验证，将抛出java.lang.IncompatibleClassChangeError异常的子类，基于方法区存储结构
       * 符号引用中通过字符串描述的全限定类名是否能找到对应的类
       * 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
       * 符号引用中的类、字段、方法的访问性是否可被当前类访问

### 准备
   目的：为类变量分配内存并设置类变量初始值（方法区分配内存，不包括实例变量，初始值通常情况下是数据类型的零值，特殊情况即为常量时会直接初始化），赋值动作在初始化阶段执行（类变量赋值putstatic指令存放在类构造器中）
### 解析（除invokedynamic外，虚拟机可以对第一次解析结果缓存）
   目的：将符号引用替换为直接引用
   > 符号引用（与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中）
   > 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可
   > 直接引用（虚拟机实现的内存布局相关，有了直接引用，引用的目标必定已经存在于内存中）
   > 直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄

   **解析时机**
   虚拟机规范并未规定解析阶段发生的具体时间，只要求在执行16个用于操作符号引用的字节码指令前，先对它们使用的符号引用进行解析（anewarray、checkcast、getfield、getstatic、instatnceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic）。虚拟机实现可以根据需要判断在类被类加载器加载时解析，还是等到一个符号引用将被使用前去解析。
   **多次解析**
   针对多次解析虚拟机需要保证在同一实体中，如果一个符号引用之前被成功解析，后续引用解析请求应当一直成功；如果第一次解析失败，那么其他指令对这个符号的解析请求也应收到相同的异常（除invokedynamic--用于动态语言支持，目前仅使用Java语言不会生成这条字节码指令，它所对应的引用称为“动态调用点限定符”，这里的“动态”的含义是必须等到程序时间运行到这条指令时，进行解析动作。相对的，其余可触发解析的指令都是“静态”的）
   **解析对象**
   主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用

#### 类或接口的解析
   当前代码所处类D  从未解析过符号引用N-->一个类或接口C的直接引用
   1. 如果C不是数组类型，虚拟机把代表N的全限定名传递给D的类加载器去加载C，这个加载过程（可能触发其他相关类的加载动作）中出现任何异常，解析过程宣告失败
   2. 如果C是数组类型，并且数组的元素类型为对象，将按照第1点规则加载数组元素类型，接着又虚拟机生成一个代表此数组维度和元素的数组对象
   3. 如果上面的步骤没有异常，那么C在虚拟机中实际上已经成为一个有效的类或接口，在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限（如果不具备，抛出java.lang.IllegalAccessError）
#### 字段解析
   前提：对字段所属类或接口C的符号引用进行解析，解析成功后对字段进行搜索
   1. 如果C本身就包含简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束
   2. 否则，如果C中实现了接口，会按继承关系从下往上递归搜索各个接口和它的父接口，如果匹配，返回直接引用，查找结束
   3. 否则，如果C不是java.lang.Object，会按继承关系从下往上递归搜索其父类，如果匹配，返回直接引用，查找结束
   4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常
#### 类方法解析（查找成功，同样进行权限验证，如果失败抛出java.lang.IllegalAccessError）
   前提：解析方法所属的类或接口的符号引用，解析成功后对类方法搜索
   1. 如果发现C是个接口，直接抛出java.lang.IncompatibleClassChangeError异常
   2. 如果通过第一步，在C中查找是否有简单名称和描述符都与目标匹配的方法，如果有则返回这个方法的直接引用，查找结束
   3. 否则，在C的父类递归查找是否存在匹配的方法，如果有则返回方法的直接引用，查找结束
   4. 否则，在C实现的接口列表以及它们的父接口之中递归查找是否有匹配的方法，如果存在，说明C是一个抽象类，查找结束，抛出java.lang.AbstractMethodError异常
   5. 否则，方法查找失败，抛出java.lang.NoSuchMethodError
#### 接口方法解析（方法默认public，不会抛出java.lang.IllegalAccessError异常）
   前提：解析方法所属类或接口符号引用，如果成功进行搜索
   1. C是类不是接口，抛出java.lang.IncompatibleClassChangeError
   2. 否则，在C中查找匹配方法，如果有返回直接引用，查找结束
   3. 否则，在C的父接口中递归查找，直到java.lang.Object类（包括Object类），看是否有匹配的方法，如果有返回直接引用，查找结束
   4. 否则，查找失败，抛出java.lang.NoSuchMethodError异常
### 初始化（真正执行类中定义的Java代码，或者说字节码）
   前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与，其余动作完全由虚拟机主导和控制。
   初始化阶段是执行类构造器<clinit>()方法的过程。（程序员可以通过程序制定的主管计划初始化类变量和其他资源）
   **类构造器方法的生成**
   <clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，收集顺序是语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
   **类构造器与实例构造器的不同**
   <clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显示调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕（虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object）
   注：<clinit>()方法对类或接口来说不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法
   **接口初始化与类初始化的不同**
   接口中不能使用静态语句块，但是仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。与类不同，执行接口<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法
   **多线程环境中类的初始化**
   虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕（<clinit>()方法耗时操作会导致多个线程阻塞）

## 类加载器
   作用：在Java虚拟机外部实现加载阶段的第一步，应用程序可以自己决定如何获取所需要的类
### 类与类加载器
   对任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间
   比较两个类是否“相等”（代表类的Class对象的equals方法、isAssignableFrom方法、isInstance方法，也包括instanceof关键字）前提：这两个类由同一个类加载器加载

### 双亲委派模型
   **类加载器的类型**
   * 启动类加载器（C++语言实现），是虚拟机自身的一部分，无法被Java程序直接引用，但是用户可以编写自定义类加载器时可以把2加载请求委派给引导类加载器
     
       > 负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar）类库加载到虚拟机内存中
   * 所有其他的类加载器（Java语言实现），独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader
       1. 扩展类加载器（由sun.miscLauncher$ExtClassLoader实现，开发者可以直接使用）
          
           > 负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库
       
      2. 应用程序类加载器（由sun.misc.Launcher$AppClassLoader实现，开发者可以直接使用）
          > 这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，一般也称为系统类加载器
          > 它负责加载用户路径（ClassPath）上所指定的类库
          > 如果应用程序中没有自定义过自己的类加载器，一般情况下，这个就是程序中默认的类加载器  

   **类加载器间关系图**
   ![类加载器双亲委派模型](D:\local\notes\images\classloadermodel.bmp)
   **类加载器的双亲委派模型（并不是一个强制性的约束模型）**
   双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器（这里的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父类加载器的代码）
   **双亲委派模型的工作过程**
   如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载
   优点：Java类随着它的类加载器一起举杯了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器，因此Object类在程序的各种类加载器环境中都是同一个类
   双亲委派模型对于保证Java程序的稳定运行很重要
### 破坏双亲委派模型
   1. 类加载器和抽象类java.lang.ClassLoader在JDK1.0时代存在，双亲委派模型在JDK1.2之后被引入（为了向前兼容JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()）,覆盖findClass()方法保证自定义的类加载器符合双亲委派规则
   2. 模型自身缺陷（双亲委派很好地解决了各个类加载器的基础类的统一问题--越基础的类由越上层的加载器进行加载），基础类总是作为被用户代码调用的API，当基础类又要调用会用户的代码问题出现
       > JNDI服务（JDK1.3时放入rt.jar），目的是对资源进行集中管理和查找，它需要调用由独立产商实现并部署在应用程序ClassPath下的JNDI接口提供者（SPI）的代码，但启动类加载器不认识这些代码
       > 解决方案（不太优雅）：线程上下文类加载器，这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程是还未设置，它会从父线程中继承一个，如果在应用程序的全局方位内都没有设置过得话，那这个类加载器默认就是应用程序类加载器
       > JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，违背了双亲委派模型的一般性原则
       > Java中所有涉及SPI的加载动作基本上都采用这种形式，如JNDI、JDBC、JCE、JAXB、JBI等  
   3. 用户对程序动态性的追求导致--代码热替换、模块热部署等（不用重启替换组件）
       > OSGI成为业界“事实上”的Java模块化标准
       > 它使用自定义类加载器机制实现模块化热部署
       > 每一个程序模块（Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换
       > 在OSGI环境下，类加载器不再是双亲委派模型中的树状结构，而成为网状结构
       当收到类加载请求时，OSGI将按一下顺序进行类搜索
       
       1. 将以java.*开头的类委派给父类加载器
       2. 否则，将委派列表名单内的类委派给父类加载器加载
       3. 否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载
       4. 否则，查找当前Bundle的Classpath，使用自己的类加载器加载
       5. 否则，查找类是否在自己的Fragment Bundle中，如果在则委派给FragmentBundle的类加载器加载
       6. 否则，查找Dynamic Import列表的Bundle，委派给对应的Bundle的类加载器加载
       7. 类查找失败
       上面的查找顺序只有开头两点符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的
## 虚拟机字节码执行引擎（Java虚拟机最核心的组成部分之一）
   **虚拟机与物理机异同**
   * 相同：都有代码执行能力
   * 不同：
       > 物理机的执行引擎直接建立在处理器、硬件、指令集和操作系统层面
       > 虚拟机的执行引擎是自己实现的（可以自行制定指令集与执行引擎的结构体系，并且能够执行不被硬件直接支持的指令集格式）  

   Java虚拟机规范定制了虚拟机字节码执行引擎的概念模型（成为各种虚拟机执行引擎的统一外观--输入字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果），不同的虚拟机实现里，执行引擎在执行Java代买时可能有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，甚至可能包含几个不同级别的编译器执行引擎
### 运行时栈帧结构
   **栈帧**
   作用：用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区的虚拟机栈的栈元素
   存储信息：栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息（额外的附加信息）
   方法调用本质：每个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程
   **栈帧分配内存**
   编译程序代码时，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入到方法表的Code属性中
   一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现
   当前栈帧：在活动线程中，位于栈顶的栈帧才是有效的，称为当前栈帧
   当前方法：与当前栈帧关联的方法称为当前方法
   执行引擎运行的所有字节码指令都只针对当前栈帧进行操作
   **栈帧结构**
   ![栈帧结构图](D:\local\notes\images\stackframe.bmp)
#### 局部变量表
   局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量
   注：在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量
   局部变量表的容量以变量槽为最小单位（虚拟机规范并没有明确指明一个Slot应占用的内存空间，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这八种数据类型都可以使用32位或更小的物理内存存放）
   reference表示对一个对象实例引用，虚拟机规范没有说明它的长度，也没有明确指出这种引用应有怎样的结构，虚拟机实现至少应当通过这个引用做到两点：
   1. 从此引用直接或间接地查找到对象所属数据类型在方法区中存储的类型信息
   2. 此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引
      returnAddress目前很少见，为字节码指令jsr、jsr_w和ret服务的，指向一条字节码指令的地址，古老的Java虚拟机会使用者几条指令实现异常处理，现在由异常表代替
      对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间，reference类型可能是32位也可能64位，64位的数据类型只有long和double两种
      **long和double的非原子性协定**
      把一次long和double数据类型读写分割为两次32位读写
      虚拟机通过索引定位的方式使用局部变量表（索引范围0-最大Slot数量）
      注：Java虚拟机规范明确如果遇到单独访问存放一个64位数据其中一个Slot的字节码序列，虚拟机应该在类加载的校验阶段抛出异常
      方法执行时，虚拟机使用局部变量表完成参数值到参数变量列表的传递过程
      如果执行实例方法，局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数，其余参数按照参数表顺序排列，占用从1开始的局部变量Slot,参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot
      注：为了尽可能节省栈帧空间，局部变量表中Slot是可以重用的，方法体中定义的变量，其作用域不一定会覆盖整个方法体（如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot可以交给其他变量使用）
      副作用：Slot的复用在某些情况会直接影响系统的垃圾收集行为
      如果遇到一个方法，其后面代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际已经不会再使用的变量，手动将其设置为null，把变量对应的局部变量表Slot清空（“奇技”--对象占用内存大、此方法栈帧时间长时间不能被回收，方法调用次数达不到JIT的编译条件）
      编码原则：不适用的对象应手动赋值为null(不应过多依赖)
      经过JIT编译器后，赋值为null的操作会被消除掉，这时将变量设置为null没有意义
      控制变量回收：恰当的变量作用域
      
      **解释器与JIT**
      * 虚拟机使用解释器执行时，通常与概念模型比较接近，经过JIT编译器后，才是虚拟机执行代码的主要方式
      * 字节码被编译成本地代码后，对GC Roots的枚举也与解释执行时期有巨大的差别
      
      **局部变量赋值**
      如果一个局部变量定义了当时没有赋初始值是不能使用的（没有类变量的准备阶段赋予系统初始值），不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔类型变量默认为false等这样的默认值
#### 操作数栈
   操作数栈的最大深度在编译时写入到Code属性的max_stacks数据项中
   操作数栈的每一个元素可以是任意类型的Java数据类型，包括long和double（32位数据类型所占的栈容量为1,64位数据类型栈容量为2）
   在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值
   **方法执行过程操作数栈情况**
   方法刚开始执行，该方法的操作数栈是空的，方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈/出栈操作，例如，在做算术运算时是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递
   注：操作数栈中元素的数据类型必须与字节码指令的序列严格匹配
   注：在概念模型中，两个栈帧作为虚拟机栈的元素，完全相互独立。但是在大多数虚拟机实现里会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递，重叠过程如图
   ![重叠过程图](D:\local\notes\images\stackframe-overlap.bmp)
   Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中栈就是操作数栈
#### 动态连接
   每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程过程中的动态连接，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数，这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接

#### 方法返回地址
   当一个方法开始执行后，只有两种方式可以退出这个方法。
   1. 执行引擎遇到任意一个方法返回的字节码指令，这个时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口
   2. 另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口，一个方法使用异常完成出口的方式退出，不会给它的上层调用者产生任何返回值
      无论采用何种方式退出，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法在返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态
      一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址栈帧中很可能会保存这个计数器值。方法异常退出时，返回地址需要通过异常处理器表来确定，栈帧中一般不会保存这部分信息
      **方法退出时可能执行的操作**
   * 恢复上层方法的局部变量表和操作数栈
   * 把返回值（如果有的话）压入调用者栈帧的操作数栈中
   * 调整PC计数器的值以指向方法调用指令后面的一条指令

#### 附加信息
   虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中
   注：一般把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息

### 方法调用
   方法调用不等同于方法执行
   任务：确定被调用的方法的版本（调用哪一个方法）
   注：暂不涉及方法内部的具体运行过程
   注：Class文件的编译过程不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用）

#### 解析
   所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用

   在类加载阶段会将其中一部分符号引用转化为直接引用
   **前提：**方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期不可改变，即调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析
   注：Java语言中符合“编译期可知，运行期不变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可访问，这两种方法各自的特点决定了他们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析

   **方法调用字节码指令**
   * invokestatic:调用静态方法
   * invokespecial:调用实例构造器<init>方法、私有方法和父类方法
   * invokevirtual:调用所有虚方法(被重写的方法)
   * invokeinterface:调用接口方法，会在运行时再确定一个实现此接口的对象
   * invokedynamic:现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法
      注：前4条调用指令，分派逻辑固化在虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的
      注：只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中指定唯一的版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4中，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以被称为非虚方法，与之相反其他方法称为虚方法（除去final方法）
      注：final方法属于非虚方法，虽然final方法使用invokevirtual指令来调用，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多台选择，又或者说多态选择的结果是唯一的
      注：解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成，而分派调用则可能是静态的也可能是动态的

   **分派类别**
   根据分派依据的宗量数可分为单分派和多分派
   这两类分派方式的两两组合构成了静态单分派、静态多分派、动态单分派、动态多分派
#### 分派
##### 静态分派
   **概念**
   `class Man extends Human{}`
   `Human man = new Man()`
   Human称为变量的静态类型，或者叫外观类型
   Man称为变量的实际类型

   静态类型和实际类型在程序中都可以发生一些变化（类型变化）
   区别：静态类型的变化仅仅在使用时变化，变量本身的静态类型不会被改变，并且最终的静态类型在编译期可知；实际类型变化的结果在运行期才确定，编译期在编译程序的时候并不知道一个对象的实际类型是什么

   虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的

   **定义**
   所有依赖静态类型来定位方法执行版本的分派动作称为静态分派

   **典型应用**
   方法重载

   **发生时机**
   编译阶段

   注：编译器虽然能确信方法的重载版本，但很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本（字面量不需要定义，所以字面量没有显示的静态类型，它的静态类型只能通过语言上的规则去理解和推断）
   注：解析与分派间的关系不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程
##### 动态分派
   动态分派和多态性的另一个重要体现（重写）有着很密切的关联

   **invokevirtual指令运行时解析过程**
   1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
   2. 如果类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllgealAccessError异常
   3. 否则，按照集成关系从下往上一次对C的各个父类进行第2不得搜索和验证过程
   4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

   **定义**
   运行期根据实际类型确定方法执行版本的分派过程称为动态分派

##### 单分派与多分派
   **宗量**
   方法的接受者与方法的参数统称为方法的宗量（这个定义最早来源于《Java与模式》）

   根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种

   注：Java语言是一门静态多分派、动态单分派的语言（未必恒久不变）
   注：Java语言没有直接变为动态语言的迹象，而是通过内置动态语言执行引擎的方式来满足动态性的需求
   注：Java虚拟机不是如此，JDK 1.7中实现的JSR-292里面就已经开始提供对动态语言的支持了
#### 虚拟机动态分派的实现（各种虚拟机的实现都会有些差别）
   动态分派是非常频繁的动作，而且动态分派的方法版本选择过程中需要运行时再类的方法元元数据中搜索合适的目标方法，虚拟机实际实现中基于性能考虑，大部分实现都不会真正地进行如此频繁的搜索

   **“稳定优化”手段**
   为类在方法区建立一个虚方法表（与此对应，在invokeinterface执行时也会用到接口方法表），使用虚方法表索引来代替元数据查找以提高性能

   **虚方法表结构**
   ![虚方法表](D:\local\notes\images\vtable.bmp)
   虚方法表中存放着各个方法的实际入口地址
   * 如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口
   * 如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址

   注：为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址
   注：方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕
   注：方法表是分派调用的“稳定优化”手段，虚拟机除了使用方法表之外，在条件允许的情况下，还会使用内联缓存和基于“类型继承关系分析”技术的守护内联两种非稳定的“激进优化”手段来获取更高的性能

#### 动态类型语言支持
  **字节码指令数量的变化**
  Sun公司的第一款Java虚拟机问世至JDK7来临之前的十余年里，一直没有发生任何变化。随着JDK7发布，字节码指令集迎来了第一位新成员-invokedynamic指令
  注：该指令是JDK7实现“动态类型语言”支持而进行的改进之一，也是为JDK8可以顺利实现Lamda表达式做技术准备
##### 动态类型语言（与动态语言、弱类型语言不是一个概念）
  **关键特征**
  类型检查的主题过程是在运行期而不是编译期
  动态类型语言(变量无类型，变量值才有类型，方法接收者不固定)：APL、Clojure、Erlang、Groovy、JavaScript、Jython、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk和Tcl等
  静态类型语言：C++和Java等

  **运行时异常与连接时异常**
  运行时异常：代码不运行到这一行就不会有问题，如NegativeArraySizeException
  连接时异常：即时会导致连接时异常的代码放在一条无法执行到的分支路径上，类加载时也照样会抛出异常，如NoClassDefFoundError

  **静态、动态类型优点**
  静态：编译器提供严谨的类型检查，利于稳定性及代码达到更大规模
  动态；为开发人员提供更大的灵活性，某些在静态类型语言中需要用大量“臃肿”代码来实现的功能，由动态类型语言来实现可能更加清晰和简洁通常也就意味着开发效率的提升
##### JDK1.7与动态类型
  1997年出版的《Java虚拟机规范》中规划了这样一个愿景：“在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行与Java虚拟机之上”。（Clojure、Groovy、Jython和Jruby）
  在一个虚拟机上可以达到静态类型语言的严谨性和动态类型语言的灵活性

  **invokedynamic指令及java.lang.invoke包出现技术背景**
  invokevirtual、invokespecial、invokestatic、invokeinterface的第一个参数都是被调用方法的符号引用（在编译时产生）
  编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配
  缺点：动态类型语言实现复杂度增加，也可能带来额外的性能或内存开销，尽管可以利用一些方法（如Call Site Caching）让这些开销变小
  这种底层问题终归应当在虚拟机层次上去解决才最合适
##### java.lang.invoke包
  目的：主要是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称为MethodHandle

  **ReflectIon和MethodHandle的区别
  * Reflection和MethodHandle机制都是在模拟方法的调用，但Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用
  * Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息多。前者是方法在Java一端的全面映像，包含了方法签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅仅包含与执行该方法相关的信息。Reflection是重量级，而MethodHandle是轻量级
  * MethodHandle是对字节码的方法指令调用的模拟，所以理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应该可以采用类似思路去支持（但目前实现还不完善）。而通过反射去调用方法则不行
  * Reflection API的设计目标只是为Java语言服务的，而MethodHandle则设计成可服务于所有Java虚拟机之上的语言，其中也包括Java语言
##### invokedynamic指令
  在某种程度上，invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke*”指令方法分派规则固话在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码中，让用户（包含其他语言的设计者）有更高的自由度
  注：它们两者的思路也是可类比的，可以把它们想象成为了达成同一目的，一个采用上层Java代码和API来实现，另一个用字节码和Class中其他属性、常量来完成

  **动态调用点**
  每一处含有invokedynamic指令的位置都被称做“动态调用点”，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK1.7新加入的CONSTATNT_InvokeDynamic_info常量

  **CONSTATNT_InvokeDynamic_info常量的信息**
  1. 引导方法（此方法存放在新增的BootstrapMethods属性中）

    引导方法是有固定的参数，并且返回值是java.lang.invoke.CallSite对象，这个代表真正要执行的目标方法调用
  2. 方法类型和名称

  根据CONSTATN_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用要执行的目标方法

  注：invokedynamic指令所面向的使用者并非Java语言，而是其他Java向虚拟机之上的动态语言，因此仅靠Java语言的编译器Javac没有办法生成带有invokedynamic指令的字节码（可以使用INDY工具来完成：把程序字节码转换为invokedynamic）
  注：引导方法由INDY产生，逻辑就是生成指定方法举办，然后用它创建一个ConstantCallSite对象，最后，这个对象返回给invokedynamic指令实现对指定方法的调用
##### 掌控分派规则
  在Java程序中，可以通过“super”关键字很方便地调用到父类中的方法，如果要反问祖父类的方法呢？（JDK1.7以前很难处理，但是可以使用ASM等字节码工具很容易做到）
  JDK1.7之后可以通过方法句柄做到

#### 基于栈的字节码解释执行引擎
##### 解释执行（具体的Java实现版本和执行引擎运行模式）
  Java语言经常被人定位为“解释执行”的语言
  注：在Java初生的JDK1.0时代，这种定义还算比较准确，直到主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情
  注：Java也发展出了可以直接生成本地代码的编译器（如GCJ-GNU Compiler for the java），而C/C++语言也出现了通过解释器执行的版本（如CINT）

  **程序代码到目标机器码的生成过程**
  如今，基于物理机、Java虚拟机，或者非Java的其他高级语言虚拟机（HLLVM）的语言，大多都会遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树AST，对一门具体预言实现来说，词法分析、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以吧其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子中，如大多数JavaScript执行器
  ![程序代码到目标机器码的生成过程图](D:\local\notes\images\compile-explain.bmp)
  注：Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现

##### 基于栈的指令集与基于寄存器的指令集
  Java编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作
  基于寄存器的指令集，最典型的就是x86的二地址指令集，也就是主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作
  **两种指令集的不同**
  基于栈的指令集主要优点是可移植，寄存器由硬件直接提供
  **基于栈的指令集**
  * 不会直接使用寄存器，就可以由虚拟机实现来自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存等）放到寄存器以获取尽量好的性能
  * 代码相对更加紧凑（字节码中每个字节对应一条指令，而多地址指令集还需要存放参数）
  * 编译器实现更加简单（不需要考虑空间分配问题，所需空间都在栈上操作）
  * 主要缺点是执行速度相对来说稍慢一些
  * 栈结构指令集的代码紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多（入栈、出栈操作本身就产生了相当多的指令数量）
  * 栈实现在内存中，频繁的栈访问意味着频繁的内存访问（对于处理器来说，内存始终是执行速度的瓶颈--虚拟机可以采取栈顶缓存，把最常用的操作映射到寄存器中避免直接内存访问，这只是优化措施而不是解决本质问题的方法）
##### 基于栈的解释执行过程
  ```java
public int calc() {
    int a = 100;
    int b = 200;
    int c = 300;
    return (a + b) * c
}
  ```
  **代码执行过程中代码、操作数栈和局部变量表的变化情况**
  ![执行偏移地址为0的指令](D:\local\notes\images\bias-0.bmp)
  ![执行偏移地址为2的指令](D:\local\notes\images\bias-2.bmp)
  ![执行偏移地址为11的指令](D:\local\notes\images\bias-11.bmp)
  ![执行偏移地址为12的指令](D:\local\notes\images\bias-12.bmp)
  ![执行偏移地址为13的指令](D:\local\notes\images\bias-13.bmp)
  ![执行偏移地址为14的指令](D:\local\notes\images\bias-14.bmp)
  ![执行偏移地址为16的指令](D:\local\notes\images\bias-16.bmp)

  注：上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能
  注：虚拟机中解析器和即时编译器都会对输入的字节码进行优化
  注：HotSpot虚拟机中，有很多以“fast_”开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，而即时编译器的优化手段更加花样繁多

## 类加载及执行子系统的案例与实战
  在Class文件格式与执行引擎这部分，用户的程序能直接影响的内容并不多，Class文件以何种格式存储，类型何时加载、何时连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变
  能通过程序进行操作的，主要是字节码生成和类加载器这两部分
### 案例分析
#### Tomcat：正统的类加载器架构
  主流的Java Web服务器，如Tomcat、Jetty、WebLogic、WebSphere后者其他服务器，都实现了自己定义的类加载器（一般不止一个）

  **一个功能健全的Web服务器要解决的几个问题**
  * 部署在同一个服务器上的两个Web应用程序所使用的的Java类库可以实现相互隔离。这是最基本的需求，两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一个类库在一个服务器中只有一份，服务器应当保证两个应用程序的类库可以相互独立使用
  * 部署在同一个服务器上的两个Web应用程序所使用的的Java类库可以相互共享。例如把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费--这主要倒不是浪费磁盘空间的问题，而是指类库使用时都要被加载到服务器内存，如果类库不能共享，虚拟机方法区很容易出现过度膨胀的风险
  * 服务器需要尽可能保证自身的安全不受部署的Web应用程序影响。许多主流的Java Web服务器自身也是使用Java语言来实现的。因此，服务器本身也有类库依赖的问题，一般来说，基于安全考虑，服务器所使用的类库应该与应用程序类库相互独立
  * 支持JSP应用的Web服务器，大多都需要支持HotSwap功能
    由于存在上述问题，部署Web应用时，单独一个ClassPath就无法满足需求，所以各种Web服务器都“不约而同”地提供了好几个ClassPath路径供用户存放第三方类库，这些路径一般以“lib”或“classes”命名。被放置在不同路径中的类库，具备不同的访问范围和服务对象，通常每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库

  **Tomcat类库目录**
  * /common
    
      > 类库可被Tomcat和所有的Web应用程序共同使用
  * /server
    
      > 类库可被Tomcat使用，对所有Web应用程序都不可见
  * /shared
    
      > 类库可被所有Web应用程序共同使用，但对Tomcat自己不可见
  * /WEB-INF
    
      > 类库仅仅可以被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见

  为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的双亲委派模型实现
  ![Tomcat类加载器架构](D:\local\notes\images\tomcat-classloader.bmp)
  注：Web类加载器和Jsp类加载器通常会存在多个实例，每个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个JSP类加载器
  注：JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class，它出现的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JsperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能

#### OSGI：灵活的类加载器架构
  学习JEE规范，去看JBoss源码；学习类加载器，就去看OSGI源码

  OSGI是OSGI联盟指定的一个基于Java语言的动态模块化规范
      > 这个规范最初由Sun、IBM、爱立信等公司联合发起，目的是使服务提供商通过住宅网关为各种家用智能设备提供各种服务，后来这个规范在Java的其他技术领域也有相当不错的发展，现在已经成为Java世界中“事实上”的模块化标准，并且已经有了Equinox、Felix等成熟实现

  **OSGI中模块（Bundle）与Java类库的异同**
  * 同： 一般都以JAR格式封装，并且内部存储的都是Java Package和Class
  * 异： 
      1. 一个Bundle可以声明它所依赖的Java Package（通过Import-Package描述），也可以声明它允许导出发布的Java Package（通过Export-Package描述）
      2. OSGI中，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖（至少外观上如此），而且类库的可见性得到非常精确的控制
      3. 基于OSGI的程序很可能可以实现模块级的热插拔功能，当程序升级更新或调试出错时，可以只体用、重新暗转然后启用程序的其中一部分

  **注意**
  * OSGI的Bundle类加载器之间只有规则，没有固定的委派关系，不涉及某个具体的Package时，各个Bundle加载器都是平级关系，只有具体使用某个Package和Class的时候，才会根据Package导入导出定义来构造Bundle间的委派和依赖
  * 一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控制访问范围
  * 两个Bundle相互依赖时会产生死锁（牺牲性能为代价的解决方案--用户可以启用osgi.classloader.singleTreadLoads参数来按单线程串行化的方式强制进行类加载动作），JDK1.7中，为非树状继承关系下的类加载器架构进行了一次专门升级，目的是从底层避免这类死锁出现的可能
  * 不是所有应用都适合采用OSGI作为基础架构，它在提供强大功能的同时，也引入了额外的复杂度，带来了线程死锁和内存泄露的风险
#### 字节码生成技术生成技术与动态代理的实现
  **字节码生成技术**
  * 字节码类库：Javaassist、CGLib、ASM
    *“老祖宗”: javac（Java语言编写成的程序）
  * 字节码生成：Web服务器中的JSP编译器，编译时植入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机可能会在运行时生成字节码来提高执行速度

  **动态代理**
  动态代理中所谓的“动态”，是针对使用Java代码实际编写代理类的“静态”代理而言的，它的优势不再于省去了编写代理类的哪一点工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同应用场景中

  动态代理通过`sun.misc.proxyGenerator.generateProxyClass()`方法来完成生成字节码的动作
  可以通过`System.getProperties().put("sun.misc.proxyeneratro.saveGeneratedFiles", "true")`获取生成的字节码文件

  **动态代理字节码生成**
  大致的生成过程就是一句Class文件的格式规范去拼装字节码
  注：在实际开发中以byte为单位直接拼装出字节码的应用场合很少见，这种生成方式也只能产生一些高度模板化的代码。对于用户的程序代码来说，如果要有操作大量字节码的需求，还是使用封装好的字节码类库比较合适
#### Retrotranslator：跨越JDK版本
  **技术更新**
  以“做项目”为主的软件公司技术更新快，以“做产品”为主的软件公司技术更新慢

  JDK1.5(自动装箱、泛型、动态注解、枚举、变长参数、遍历循环)
  保护现有投资、维持程序结构稳定而必须使用1.5以前版本的JDK
  把JDK1.5中编写的代码放到JDK1.4或1.3的环境中去部署使用

  Java你想移植工具--Retrotranslator是这类工具中较为出色的一个

  **Retrotranslator的作用**
  将JDK1.5编译出来的Class文件转变为可以在JDK1.4或1.3上部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK1.5中新增的集合改进、并发包以及对泛型、注解等的反射操作

  **JDK升级提供的新功能**
  * 在编译器层面做的改进。 自动装箱拆箱（编译器自动插入Integer.valueOf()等）；变长参数（编译之后自动转化成一个数组完成参数传递）；泛型信息在编译阶段擦除（元数据中保留），相应的地方被编译器自动插入类型转换代码
  * 对Java API的代码增强。JDK1.2时代引入java.util.Collections等一系列集合类，在JDK1.5时代引入的java.lang.concurrent并发包
  * 需要在字节码中进行支持的改动。JDK1.7里新加入的语法特性：动态语言支持（新增invokedynamic字节码指令）
  * 虚拟机内部的改进。JDK1.5中实现的JSR-133规范新定义的Java内存模型（JMM），这类改动对于程序员编写代码基本是透明的，但会对程序运行时产生影响

  Retrotranslator只能模拟前两类，对于后面两类直接在虚拟机内部实现的改进，一般所有的逆向移植工具都是无能为力的，至少不能完整地或者在可接受的效率上完成全部模拟

  在可模拟的两类功能中，第二类模拟相对更容易实现，如JDK1.5引入的java.lang.concurrent包在1.5前已经存在（叫dl.util.concurrent，引入JDK时由作者和JDK开发团队共同做了一些改进），在旧的JDK中支持这部分功能，以独立类库的方式便可实现
  Retrotranslator中附带了一个叫“backport-util-concurrentjar”类库来代替JDK1.5并发包

  JDK编译阶段进行处理的改进，Retrotranslator使用ASM框架直接对字节码进行处理
  JDK1.3、JDK1.4、JDK1.5，字节码表达的语义范围一致（组成Class文件的字节码指令数量没有改变）
  JDK1.5增加了enum关键字，从字节码角度看，枚举仅仅是一个继承于java.lang.Enum、自动生成了values()和valueOf()方法的普通Java类
  Retrotranslator对枚举做的主要处理就是把枚举类的父类从`java.lang.Enum`替换为它运行时类库中包含的`net.sf.retrotranslator.runtime.java.lang.Enum`，然后再在类和字段的访问标志中抹去ACC_ENUM标志位
### 实战：自己手动实现远程执行功能
  **问题**
  程序维护：排查问题想要查看内存中一些参数值，却没有方法把浙西值输出到界面或日志，又或者定位到某个缓存数据有问题，但缺少缓存的统一管理界面，不得不重启服务才能清理这个缓存
  **途径**
  服务器执行临时代码
  JDK1.6之后提供了Compiler API，可以动态编译Java程序，虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求可以解决
  JDK1.6之前，可以通过其他方式来做到，如写一个JSP文件上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个BeanShell Script、JavaScript等的执行引擎（如Mozilla Rhino）去执行动态脚本
#### 目标
  * 不依赖JDK版本
  * 不改变原有服务端程序部署，不依赖任何第三方类库
  * 不侵入原有程序（无须改动原程序的任何代码，也不会对原有程序的运行带来任何影响）
  * 考虑BeanShell Script或JavaScript等脚本编写起来不太方便，“临时代码”需要直接支持Java语言
  * “临时代码”应当具备足够的自由度，不需要依赖特定的类或实现特定的接口
  * “临时代码”的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等
#### 思路
  **问题**
  1. 如何编译提交到服务器的Java代码
      * 使用tools.jar（在SunJDK/lib目录下）中的com.sun.tools.javac.Main类来编译Java文件，这和使用Javac命令编译一样（缺点：引入了额外的JAR包，而且把程序“绑死”在Sun的JDK上了）
      * 直接在客户端编译好，把字节码而不是Java代码传到服务端
  2. 如何执行编译后的Java代码
      * 让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法（临时代码，提交的Java类在执行完后就应当能卸载和回收）
  3. 如何收集Java代码的执行结果
      * 标准输出和标准错误输出是整个虚拟机紧凑全局共享的资源，直接把它们重定向对原有程序产生影响。
      * 直接在执行的类中把System.out的符号引用替换为我们准备的PrintStream的符号引用
 #### 实现
  1. 对于第二个问题，实现一个HotSwapClassLoader类加载器
  2. 对于第三个问题，实现一个ClassModifier和一个ByteUtils完成符号引用替换
  3. 需要实现一个自定义类，仿照java.lang.System
  4. 使用JavaClassExecuter提供外部调用的入口，调用前面几个支持类组装逻辑
#### 验证
  1. 编写一个Java类，编译后传送到服务器指定目录，建立一个JSP文件调用JavaClassExecuter.execute()方法，并返回执行结果
  2. 编写一个Eclipse插件，把Java文件编译后传输到服务器中，然后把执行器的返回结果输出到Eclipse的Console窗口
  