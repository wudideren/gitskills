# <center>虚拟机类加载机制</center>
   代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，确实编程语言发展的一大步。  

> **编译型语言**
>
> 1. 类C语言
>     * 编译时将源代码编译成本地机器码
>     * 编译时进行连接
> 2. 类java语言
>     * 编译时将源代码编译成字节码
>     * 类型的加载、连接和初始化过程都是在程序运行期间完成的
>         > 缺点：类加载时会稍微增加一些性能开销
>         > 优点：为Java应用程序提供高度的灵活性（动态扩展的语言特性）  

**虚拟机的类加载机制**
   虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型

***

## 类加载的时机

   生命周期：加载、验证、准备、解析、初始化、使用和卸载七个阶段

   连接：验证、准备和解析

   类的生命周期图：
   ![类的生命周期](D:\local\notes\images\lifecircle.png)  

   类的加载过程的开始顺序：加载、验证、准备、初始化和卸载
   解析阶段在某些情况下可以在初始化阶段之后开始（Java的运行时绑定，也称动态绑定或晚期绑定）
   这些阶段通常是互相交叉地混合式进行，通常会在一个阶段执行过程中调用、激活另外一个阶段
***
   > **加载时机和初始化时机**
   > 1. 加载时机
   >     与虚拟机的具体实现相关（Java虚拟机规范没有强制约束）
   > 2. 初始化时机
   >     * 遇到字节码指令new、getstatic、putstatic或invokestatic，如果类没有初始化，则需要先触发其初始化
   >         > new: 使用new关键字实例化对象，创建数组时不会触发类初始化，但会触发对应数组类的初始化（字节码指令newarray，由虚拟机自动生成、直接继承java.lang.Object）
   >         > getstatic、putstatic: 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外，常量传播优化），只有直接定义这个字段的类被初始化，通过子类来引用父类中定义的静态字段，只会触发父类初始化而不会触发子类初始化
   >         > invokestatic: 调用一个类的静态方法
   >     * 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
   >     * 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
   >     * 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化主类
   >     * JDK7,如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic、REF_putstatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化
   > 这五种场景的行为被称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发初始化，称为被动引用
***
**接口**
   编译器会为接口生成<clinit>()类构造器，用于初始化接口中定义的成员变量
   接口加载过程与类加载过程稍有不同，接口初始化时，并不要求其父接口全部都完成初始化
## 类的加载过程
### 加载
#### 非数组类的加载过程
   1. 通过一个类的全限定名获取定义此类的二进制字节流（二进制字节流来源：Class文件、ZIP包、网络、运行时计算生成，由其他文件生成和从数据库读取等等），相较于其他阶段此阶段开发人员可控性最强（非数组类的加载阶段）
   2. 将这个字节流代表的静态数据结构转化为方法区运行时数据结构（存储格式由虚拟机实现自行定义）
   3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口（没有明确规定存放在Java堆中，对于HotSpot虚拟，Class对象比较特殊，存放在方法区）
#### 数组类的记载过程
   数组类不同过类加载器创建，而是由Java虚拟机直接创建
   1. 数组的组件类型（去掉一个维度的类型）是引用类型，则递归采用加载过程加载此组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识
   2. 数组的组件类型不是引用类型，Java虚拟机会把数组标记为与引导类加载器关联
      数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那么数组类的可见性默认为public
### 验证（非常重要、但不一定必要）
   目的：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
   Class文件来源：Java源代码编译，以及任何途径产生，甚至使用十六进制编辑器直接编写（字节码语言层面表达能力比Java更强）
   > Java语言本身相对安全
   > 1. 无法访问数组边界以外的数据
   > 2. 将一个对象类型转型为它并未实现的类型
   > 3. 跳转到不存在的代码行  

**验证阶段的虚拟机规范**
   一些Class文件格式中的静态和结构化约束（如果输入字节流步符合Class文件格式的约束，虚拟机应该抛出一个java.lang.VerifyError异常或其子类）
   1. 文件格式验证（验证字节流是否符合Class文件格式的规范，并且能被当前版本虚拟机处理），基于二进制字节流
       * 是否以魔数0xCAFEBABE开头
       * 主、次版本号是否在当前虚拟机处理范围之内
       * 常量池中的常量是否有不被支持的常量类型（检查常量tag标志）
       * 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
       * CONSTATNT_Utf8_info型的常量中是否有不符合UTF8编码的数据
       * Class文件中各个部分及文件本身是否有被删除的或附加的其他信息
   2. 元数据验证（语义分析，保证字节码描述的信息符合Java语言规范），对元数据信息中的数据类型进行校验，基于方法区存储结构
       * 这个类是否有父类（除了java.lang.Object）
       * 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
       * 如果这个类不是抽象类，是否实现了父类或接口之中要求实现的所有方法
       * 类中的字段、方法是否与父类产生矛盾（如覆盖了父类的final字段，或者出现不符合规则的方法重载，如方法参数一致，但返回值类型不同）
   3. 字节码验证（通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的），对类的方法体进行校验分析，保证被校验该类的方法在运行时不会做出危害虚拟机安全的事件，基于方法区存储结构（通过程序校验程序逻辑无法做到绝对准确-Halting Problem，最复杂的一个阶段）
      * 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
      * 保证跳转指令不会跳转到方法体以外的字节码指令
      * 保证方法体中的类型转换有效
      由于数据流验证的高复杂性，通过给方法体的Code属性的属性表中增加了一项名为StackMapTable属性进行优化（JDK6之后的Javac编译器和Java虚拟机）
      StackMapTable：描述了方法体中所有基本块（按控制流拆分的代码块）开始时的本地变量表和操作栈应有的状态（类型推导转变为类型检查）
   4. 符号引用验证（发生在虚拟机将符号引用转化为直接引用时-解析阶段发生，可以看做是对类自身以外的信息-常量池中各种符号引用进行匹配性校验），确保解析动作正常执行，如果无法通过符号引用验证，将抛出java.lang.IncompatibleClassChangeError异常的子类，基于方法区存储结构
       * 符号引用中通过字符串描述的全限定类名是否能找到对应的类
       * 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
       * 符号引用中的类、字段、方法的访问性是否可被当前类访问

### 准备
   目的：为类变量分配内存并设置类变量初始值（方法区分配内存，不包括实例变量，初始值通常情况下是数据类型的零值，特殊情况即为常量时会直接初始化），赋值动作在初始化阶段执行（类变量赋值putstatic指令存放在类构造器中）
### 解析（除invokedynamic外，虚拟机可以对第一次解析结果缓存）
   目的：将符号引用替换为直接引用
   > 符号引用（与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中）
   > 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可
   > 直接引用（虚拟机实现的内存布局相关，有了直接引用，引用的目标必定已经存在于内存中）
   > 直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄

   **解析时机**
   虚拟机规范并未规定解析阶段发生的具体时间，只要求在执行16个用于操作符号引用的字节码指令前，先对它们使用的符号引用进行解析（anewarray、checkcast、getfield、getstatic、instatnceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic）。虚拟机实现可以根据需要判断在类被类加载器加载时解析，还是等到一个符号引用将被使用前去解析。
   **多次解析**
   针对多次解析虚拟机需要保证在同一实体中，如果一个符号引用之前被成功解析，后续引用解析请求应当一直成功；如果第一次解析失败，那么其他指令对这个符号的解析请求也应收到相同的异常（除invokedynamic--用于动态语言支持，目前仅使用Java语言不会生成这条字节码指令，它所对应的引用称为“动态调用点限定符”，这里的“动态”的含义是必须等到程序时间运行到这条指令时，进行解析动作。相对的，其余可触发解析的指令都是“静态”的）
   **解析对象**
   主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用

#### 类或接口的解析
   当前代码所处类D  从未解析过符号引用N-->一个类或接口C的直接引用
   1. 如果C不是数组类型，虚拟机把代表N的全限定名传递给D的类加载器去加载C，这个加载过程（可能触发其他相关类的加载动作）中出现任何异常，解析过程宣告失败
   2. 如果C是数组类型，并且数组的元素类型为对象，将按照第1点规则加载数组元素类型，接着又虚拟机生成一个代表此数组维度和元素的数组对象
   3. 如果上面的步骤没有异常，那么C在虚拟机中实际上已经成为一个有效的类或接口，在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限（如果不具备，抛出java.lang.IllegalAccessError）
#### 字段解析
   前提：对字段所属类或接口C的符号引用进行解析，解析成功后对字段进行搜索
   1. 如果C本身就包含简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束
   2. 否则，如果C中实现了接口，会按继承关系从下往上递归搜索各个接口和它的父接口，如果匹配，返回直接引用，查找结束
   3. 否则，如果C不是java.lang.Object，会按继承关系从下往上递归搜索其父类，如果匹配，返回直接引用，查找结束
   4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常
#### 类方法解析（查找成功，同样进行权限验证，如果失败抛出java.lang.IllegalAccessError）
   前提：解析方法所属的类或接口的符号引用，解析成功后对类方法搜索
   1. 如果发现C是个接口，直接抛出java.lang.IncompatibleClassChangeError异常
   2. 如果通过第一步，在C中查找是否有简单名称和描述符都与目标匹配的方法，如果有则返回这个方法的直接引用，查找结束
   3. 否则，在C的父类递归查找是否存在匹配的方法，如果有则返回方法的直接引用，查找结束
   4. 否则，在C实现的接口列表以及它们的父接口之中递归查找是否有匹配的方法，如果存在，说明C是一个抽象类，查找结束，抛出java.lang.AbstractMethodError异常
   5. 否则，方法查找失败，抛出java.lang.NoSuchMethodError
#### 接口方法解析（方法默认public，不会抛出java.lang.IllegalAccessError异常）
   前提：解析方法所属类或接口符号引用，如果成功进行搜索
   1. C是类不是接口，抛出java.lang.IncompatibleClassChangeError
   2. 否则，在C中查找匹配方法，如果有返回直接引用，查找结束
   3. 否则，在C的父接口中递归查找，直到java.lang.Object类（包括Object类），看是否有匹配的方法，如果有返回直接引用，查找结束
   4. 否则，查找失败，抛出java.lang.NoSuchMethodError异常
### 初始化（真正执行类中定义的Java代码，或者说字节码）
   前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与，其余动作完全由虚拟机主导和控制。
   初始化阶段是执行类构造器<clinit>()方法的过程。（程序员可以通过程序制定的主管计划初始化类变量和其他资源）
   **类构造器方法的生成**
   <clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，收集顺序是语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
   **类构造器与实例构造器的不同**
   <clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显示调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕（虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object）
   注：<clinit>()方法对类或接口来说不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法
   **接口初始化与类初始化的不同**
   接口中不能使用静态语句块，但是仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。与类不同，执行接口<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法
   **多线程环境中类的初始化**
   虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕（<clinit>()方法耗时操作会导致多个线程阻塞）
## 类加载器
   