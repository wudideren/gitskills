# <center>程序编译与代码优化</center>
## 早期（编译期）优化
  Java语言的“编译期”是一段“不确定的操作过程

  * 前端编译器：把*.java文件转变为*.class文件
  * 后端运行编译器：把字节码转变为机器码的过程（JIT）
  * 静态提前编译器：直接把*.java文件编译成本地机器码的过程（AOT）
  
  * 前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）
  * JIT编译器：HotSpot VM的C1、C2编译器
  * AOT编译器：GCJ、Excelsior JET

  Javac编译器对代码的运行效率几乎没有任何优化措施（JDK1.3后，Javac的-O优化参数就不再有意义），但Javac做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率
  虚拟机设计团队把对性能的优化集中到了后端的即时编译器中（这样可以让不是由Javac产生的Class文件同样能享受到编译器优化带来的好处）
  前端编译器在编译器的优化过程对程序编码来说关系密切，后端运行编译器对程序运行更为重要
### Javac编译器
  HotSpot虚拟机使用C++语言实现（少量C语言）

  Javac编译器由Java语言编写
#### Javac的源码与调试
  虚拟机规范严格定义了Class文件的格式，但是《Java虚拟机规范（第2版）》中，没有对如何把Java源文件代码转变为Class文件的编译过程进行十分严格的定义
  Class文件编译在某种程度上与具体JDK实现相关

  **Javac编译过程**
  1. 解析与填充符号表过程
  2. 插入式注解处理器的注解处理过程
  3. 分析与字节码生成过程

    ![编译过程](D:\local\notes\images\javac-compile.bmp)
    ![编译过程主体代码](D:\local\notes\images\javac-code.bmp)
#### 解析与填充符号表
  `parseFiles()`：解析步骤包括了词法分析和语法分析两个过程
##### 词法、语法分析
  词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记
  在Javac源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现

  语法分析是根据Token序列构造抽象语法树的过程
  抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构）
  在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的AST由com.sun.tools.javac.tree.JCTree
  经过这个步骤后，编译器基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树上
  ![抽象语法树结构视图](D:\local\notes\images\AST.bmp)
##### 填充符号表
  在Javac源码中，enterTrees()负责填充符号表，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表，包含了每一个编译单元的AST的顶级节点，以及package-info.java（如果存在的话）的顶级节点
  符号表是由一组符号地址和符号信息构成的表格
  符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等，符号表所登记的信息在编译的不同阶段都要用到
  * 在语义分析中，符号表所登记的内容将用于语义检测（如检查一个名字的使用和原先的说明是否一致）和产生中间代码
  * 在目标代码生成阶段，当对符号表进行地址分配时，符号表是地址分配的依据
#### 注解处理器
  JDK1.5后，Java语言提供了对注解支持，这些注解与普通Java代码一样，在运行期发挥作用
  JDK1.6实现了JSR-269规范，提供了一组插入式注解处理器的标准API在编译器对注解进行处理（可以把它看做是一组编译器的插件）
  在这些插件里，可以读取、修改、添加抽象语法树的任意元素
  如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，指到所有插入式注解处理器都没有再都语法树进行修改，每一次循环称为一个Round
  在Javac源码中，插入式注解处理器的初始化过程是在initProcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成的，这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing()方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理
#### 语义分析与字节码生成
  AST能够表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的
  语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查
  注：是否符合语义逻辑必须限定在具体的语言与具体的上下文环境中才有意义
##### 标注检查
  Javac的编译过程，语义分析系过程分为标注检查以及数据及控制流分析，分别有attribute()和flow()方法完成

  **标注检查的内容**
  1. 变量使用前是否被声明
  2. 变量与赋值间的数据类型是否能够匹配

    注：标注检查步骤中有一个重要的动作称为常量折叠
    `int a = 1 + 2`
    ![常量折叠](D:\local\notes\images\constant-fold.bmp)
    标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类
##### 数据及控制流分析
  数据及控制流分析是对程序上下文逻辑更进一步的验证
  1. 程序局部变量使用前是否赋值
  2. 方法的每条路径是否都有返回值
  3. 是否所有的受查异常都被正确处理了

    编译期的数据及控制流分析与类加载时的数据及控制流分析的目的基本一致，但校验范围有所区别，有一些检验项只有在编译期或运行期才能进行。

  **final语义校验**
  ```java
//方法一带有final修饰
public void foo(final int arg) {
    final int var = 0;
    //do something
}
//方法二没有final修饰
 public void foo(int arg) {
     int var = 0;
     //do something
 }
  ```
  这两段代码编译出来的Class文件没有一点区别

  **局部变量与字段的区别**
  1. 局部变量在常量池中没有CONSTANT_Fieldref_info的符号引用（自然就没有访问标志Access_Flags的信息）
  2. 局部变量可能连名称都不会保留下来（取决于编译时选项）

    自然在Class文件中不可能指导一个局部变量是否声明为FInal了，因此将局部变量声明为final对运行期没有影响，变量的不变性由编译器在编译期保障
    在Javac的源码中，数据及控制流分析的入口是flow()方法，具体操作由com.sun.tools.javac.comp.Flow类来完成
##### 解语法糖
  语法糖，也称糖衣语法，是由英国计算机科学家彼得·约翰·兰达发明的一个术语
  语法糖指计算机语言中添加某种语法对语言的功能没有影响，但更方便程序员使用
  语法糖能够增加程序的可读性，从而减少程序代码出错的机会

  Java在现代编程语言中属于“低糖语言”（相对于C#及许多其他JVM语言来说）
  Java中最常用的语法糖主要是泛型（泛型不一定都是语法糖实现，C#的泛型是由直接CLR支持的）、变长参数、自动装箱/拆箱

  虚拟机在运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖
  在Javac的源码中，解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成
##### 字节码生成
  字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面有com.sun.tools.javac.jvm.Gen类来完成
  字节码生成阶段不仅把前面各个步骤生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作
  例如，实例构造器<init>()和类构造器<clinit>()方法就是在这个阶段添加到语法树中的
  注：这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成
  注：这两个构造器的产生构成实际上是一个代码收敛的过程，编译器会把语句块（实例构造器是“{}”块，类构造器是“static{}”块、变量初始化（实例变量和类变量）、调用父类的实例构造器-仅仅是实例构造器，<clinit>()方法中无须调用父类的<clinit>()方法，虚拟机会自动保证父类构造器执行，但在<clinit>()方法中经常会生成调用java.lang.Object的<init>()方法的代码）等操作收敛到<init>()和<clinit>()方法中，并且保证一定是先执行父类实例构造器，然后初始化变量，最后执行语句块
  上述动作有Gen.normalizeDefs()方法实现

  除了生成构造器以外，还有一些代码替换工作用语优化程序的实现逻辑
  字符串的家操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK1.5）的append()操作

  完成了对语法树的遍历和调整后，就会把填充了所有所需信息的符号表交个com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass()方法输出字节码，生成最终的Class文件

### Java语法糖的味道
  **语法糖（编译器“小把戏”）**
  * 优点
      1. 或能提高效率
      2. 或能提升语法严谨性
      3. 或能减少编码出错的机会
  * 缺点
      1. 程序员产生依赖
      2. 无法看清语法糖的糖衣背后，程序代码的真实面目  
#### 泛型与类型擦除
  泛型本质是参数化类型的应用，也就是操作的数据类型被指定为一个参数。
  这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法
  泛型思想早在C++语言的模板中就开始生根发芽，在Java语言还没出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化（Object转型成任何对象都是有可能的，因为无限可能性，只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象，编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期）

  **C#与Java中的泛型技术（实现上本质不同）**
  * C#泛型无论在程序源码中、编译后的IL中（中间语言，这时泛型是一个占位符），或是运行期的CLR中都是切实存在的，List<int>与List<String>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型
  * Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（也称为裸类型）了，并且在相应的地方插入了强制转型代码，对运行期的Java语言来说，ArrayList<int>与ArrayList<String>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型

  **伪泛型**
  1. 部分人认为强制转型操作和运行期缺少针对类型的优化导致比C#的泛型慢一些
  2. 作者认为选择从性能角度上评价用于提升语义准确性的泛型思想不太恰当

  通过擦触法来实现泛型丧失了一些泛型思想该有的优雅
  * 泛型遇见重载1--类型擦除成相同原生类型导致无法重载（无法重载部分原因）
  ```java
  public GenericTypes{
      public static void method(List<String> list) {
          System.out.println("invoke method(List<String> list)");
      public static void method(List<Integer> list) {
          System.out.println("invoke method(List<Integer>List)")
      }
      }
  }
      
  
  ```
  * 泛型遇见重载2
  ```java
public class GenericTypes{
     public static String method(List<String> list) {
          System.out.println("invoke method(List<String> list)");
         return "";
     }
      public static int method(List<Integer> list) {
          System.out.println("invoke method(List<Integer>List)");
          return 1;
      }
      public static void main(String[] args) {
          method(new ArrayList<String>());
          method(new ArrayList<Integer>);
      }
}
//可以编译并执行
  ```
  注：Java语言中返回值不参与重载，但在Class文件格式中，只要描述符不是完全一致的两个方法就可以共存

  JCP组织对虚拟机规范做出了修改（泛型引入，各种场景-虚拟机解析、反射等下的方法调用都可能对原有基础常识影响和新的需求，如在泛型类中如何获取传入的参数化类型等），引入诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题
  Signature是其中最重要的一项属性，存储一个方法在字节码层面的特征签名（方法独一无二且不可重复的ID），Java代码方法签名：方法名称、参数顺序及参数类型；字节码方法签名：还包括方法返回值及受查异常表。这个属性中保存的参数类型不是原生类型，而是包括了参数化类型的信息
  注：擦除法仅仅对方法Code属性中的字节码进行擦除，实际元数据中还保留了泛型信息，这是能通过反射手段取得参数化类型的根本依据
#### 自动装箱、拆箱与遍历循环
  自动装箱、拆箱编译后转化成了对应的包装方法和还原方法，如Integer.valueOf()和Integer.intValue()方法，而遍历循环则把代码还原成了迭代器实现（遍历循环需要遍历的类实现Iterable接口），变长参数调用时变成了一个数组类型的参数

  **自动装箱的陷阱**
  包装类的"=="运算在不遇到算术运算的情况下不会自动拆箱，以及它们equals方法不处理数据转型
  注：包装类型比较最好使用equals并且进行同类型比较
#### 条件编译
  C、C++使用预处理器指示符（#ifdef）来完成条件编译，它们的预处理器最初的任务是解决编译时的代码依赖关系（如#include预处理命令）
  Java语言的编译方式-编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息，无须使用预处理器

  **Java条件编译（也是语法糖）**
  使用条件为常量的if语句（如果使用常量与其他带有条件判断能力的语句搭配，则可能在控制流分析中提示错误，被拒绝编译）
  根据布尔常量值的真假，编译器将把分支中不成立的代码块消除掉，这一工作在编译器解除语法糖阶段完成
  注：这种方式必须遵循最基本的Java语法，只能写在方法体内部，因此只能实现语句基本块级别的条件编译，而没有办法实现根据调整整个Java类的结构

  其他语法糖：内部类、枚举类、断言语句、对枚举和字符串（在JDK1.7中支持）的switch支持、try语句中第一和关闭资源（在JDK1.7中支持）等
### 实战：插入式注解处理器
  一套编程语言中编译子系统的优劣，很大程度决定了程序运行性能的好坏和编码效率的高低
#### 实战目标
  编译器把Java程序源码编译为字节码时，会对Java程序源码各方面检查校验（主要以程序”写得对不对“，较少校验程序”写得好不好“）

  **程序“写得好不好”辅助校验工具**
  * CheckStyle
  * FindBug
  * Klocwork
    这些代码校验工具有一些基于Java源码进行校验，还有一些是通过扫描字节码来完成

  目标：使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor
  《Java语言规范（第3版）》中第6.8节要求，Java程序命名规范
  * 类（或接口）：符合陀式命名法，首字母大写
  * 方法：符合驼式命名法，首字母小写
  * 字段
      * 类或实例变量：符合驼式命名法，首字母小写
      * 常量：要求全部由大写字母或下划线构成，并且第一个字符不能是下划线
#### 代码实现
  1. 继承抽象类javax.annotation.processing.AbstractProcessor
  2. 覆盖抽象方法：process()-它是Javac编译器在执行注解处理器代码时要调用的过程
  3. 该方法第一个参数annotations获取此注解处理器所要处理的注解集合
  4. 第二个参数roundEnv访问到当前这个Round中语法树的节点，每个语法树节点在这表示为一个Element
  5. 除了process()方法传入的参数外还有很常用的实例变量processingEnv，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候创建，它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量
  6. 注解处理器除了process()方法及其参数外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表这个注解处理器对那些注解感兴趣，可使用“*”作为通配符代表对所有注解都感兴趣，后者支持这个注解处理器可以处理哪些版本的Java代码

  **Element（JDK1.6javax.lang.model）**
  Java代码中最常用的元素：包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CANSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT）、实例语句块（INSTATNCE_INIT）、参数化类型（TYPE_PARAMETER）和未定义的其他语法树节点（OTHER）

  注：每个注解处理器运行时都是单例的
  注：如果不需要改变或生成语法树的内容，process()方法可以返回false，通知编译器这个Round中代码未发生变化，无须构造新的JavaCompiler实例
#### 运行与测试
  通过Javac命令的-processor参数来执行编译时需要附待的注解处理器，如果有多个，用逗号分隔。还可使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息
#### 其他应用案例
  JSR-269嵌入式注解处理器API还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processor、自动为字段生成getter和setter方法的项目lombok（根据已有元素生成新的语法树）
## 晚期（运行期）优化
### 编译优化技术
  Java程序员共识：编译方式执行本地代码比解释方式更快
  * 虚拟机解释执行字节码时额外消耗时间
  * 虚拟机团队几乎把对代码的所有优化措施都集中在JIT中（在JDK1.3后，Javac就去除了-O选项，不会生成任何字节码级别的优化代码了）
    一般来说，JIT产生的本地大妈比Javac产生的字节码更优秀（由编译器优化得到的本地机器码与由解释器解释字节码后实际执行的本地代码之间的对比）
###概述
    部分商用虚拟机（Sun HotSpot、IBMJ9）中，Java程序最初是通过解释器进行解释执行，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。
    为了提高热点代码执行效率，在运行时虚拟机会使用JIT将这些代码编译器成本地平台相关的机器码，并进行各种层次的优化

  即时编译器并不是虚拟机必需的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器存在，更没有限定或指导即时编译器应该如何实现
  即时编译器编译性能的好坏、代码优化程度地高低是衡量一款商用虚拟机优秀与否的最关键指标之一（它是虚拟机中最核心且最能体现虚拟机技术水平的部分）
### HotSpot虚拟机内的即时编译器
  1. 为何HotSpot虚拟机要是用解释器与编译器并存的架构？
  2. 为何HotSpot虚拟机要实现两个不同的即时编译器？
  3. 程序何时使用解释器执行？何时使用编译器执行？
  4. 哪些程序代码会被编译为本地代码？如何编译为本地代码？
  5. 如何从外部观察即时编译器的编译过程和编译结果？
#### 解释器与编译器
  并不是所有Java虚拟机都采用解释器与编译器并存的架构（JRockit内部没有解释器，一次会存在“启动响应时间长”，主要面向服务端--这类应用一般不关注启动时间）

  **解释器**
  * 程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行
  * 当程序运行环境内存资源限制较大（如部分嵌入式系统）中，可以使用解释执行节约内存
  * 解释器可以作为编译器激进优化手段的“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化假设不成立（如加载了新类后类型继承结构出现变化、出现“罕见陷阱”）时可以通过逆优化退回到解释状态继续执行
    注：部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器担任“逃生门”的角色
    **编译器**
  * 随着时间推移，编译器逐渐发挥最庸，把越来越多的代码编译成本地代码后，可以获得更高的执行效率
  * 当程序运行环境对内存资源限制较小，可以使用编译执行来提升效率

  ![解释器与编译器配合工作](D:\local\notes\images\interperter-compiler.bmp)

  HotSpot虚拟机内置两个即时编译器分别称为Client Compiler和Server Compiler（C1编译器和C2编译器-也叫Opto编译器）
  目前主流HotSpot虚拟机（Sun系列JDK1.7及之前的版本的虚拟机）中，默认采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器，取决于虚拟机的运行模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式（用户可使用-client或-server参数强制指定虚拟机运行在Client模式或Server模式）
  注：无论采用的编译器是C1还是C2，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”（用户可以使用参数-Xint强制虚拟机运行于解释模式，也可以使用参数-Xcomp强制虚拟机运行于编译模式--前者编译器完全不介入工作，全部代码使用解释方式执行；后者有限采用编译方式执行程序，但解释器仍然要在编译无法进行的情况下接入执行过程）
  注：可以使用虚拟机的-version命令输出显示这三种模式

  **分层编译（权衡程序启动响应速度与运行效率）**
  1. 编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长
  2. 要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，对解释执行的速度也有影响
    注：分成编译的概念在JDK1.6时期出现，一直处于改进阶段，最终在JDK1.7的Server模式虚拟机中作为默认编译策略被开启

  分层编译根据编译器编译、优化的规模与耗时、划分出不同编译层次
  1. 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译
  2. 第1层，也称C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要加入性能监控逻辑
  3. 第2层（或第2层以上），也称C2编译，也是将字节am编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化
    注：实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能被多次编译，用C1编译器获取更高的编译速度，用C2编译器获取更好地编译质量，在解释执行的时候也无须再承担收集性能监控信息（编译依据）的任务
#### 编译对象与触发条件
  **热点代码（被即时编译器编译）**
  * 被多次调用的方法
      
      > 整个方法作为编译对象（这种编译时虚拟机中标准的JIT编译方式）
  * 被多次执行的循环体（解决一个方法制备调用一次或少量几次，但方法体内部存在循环次数较多的循环体问题）
      > 尽管编译动作由循环体触发，但编译器仍然以整个方法作为编译对象
      > 这种编译方式因为编译发生在方法执行过程中，因此信息地称为栈上替换简称OSR编译，即方法栈帧还在栈上，方法就被替换了
      
  **热点探测（最近流行-基于踪迹的热点探测）**
  判断一段代码是不是热点代码，是不是需要触发即时编译
  1. 基于采样的热点探测：采用这种方法的虚拟机会周期性检查各个线程的栈顶，如果发型某个（或某些）方法经常出现在栈顶，那这个方法就是“热点探测”
      * 基于采样的热点探测好处是是实现简单、高效，可以很容易获取方法调用关系（展开调用堆栈）
      * 缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测
  2. 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定阈值就认为它是“热点方法”
      * 这种方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法调用关系
      * 这种方法统计结果相对来说更加精确和严谨
  
  注：HotSpot虚拟机使用的是第二种-基于计数器的热点探测方法（它为每个方法准备了两类计数器：方法调用计数器和回边计数器）
  注：在虚拟机运行参数确定前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译
  注：进行热点探测不一定要知道方法具体被调用了多少次
  
  **方法调用计数器**
  目的：统计方法被调用次数
  Client模式下默认阈值1500次；Server模式下10000次
  这个阈值可以通过虚拟机参数-XX:compileThreshold来认为设定
  注：当一个方法被调用时，会先检查该方法是否存在被JIT编译过得版本，如果存在，则优先使用编译后的本地代码来执行。如果该不存在已经被编译过得版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值。如果已经超过阈值，将向编译器提交一个该方法的代码编译请求
  注：如果不做任何设置，执行引擎不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行代码，直到提交的请求被编译器编译完成（当编译工作完成后，这个方法的调用入口地址会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本）
  ![JIT编译交互过程](D:\local\notes\images\Invocation-counter.bmp)
  注：如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，二三十一个相对的执行频率（一段时间内方法被调用的次数）
  注：当超过一定的时间限度，如果方法调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半-这个过程称为方法调用计数器热度的衰减；这段时间称为此方法计数器的半衰周期
  注：进行热度衰减动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UserCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数（只要系统运行时间足够长，绝大部分方法都会被编译成本地代码）
  注：可以使用-XX:CounterHalfLifeTime参数设置半衰周期，单位是秒
  
  **回边计数器**
  目的：统计一个方法中循环体代码执行的次数，触发OSR编译
  回边：在字节码中遇到控制流向后跳转的指令称为“回边”（空循环，不会被回边计数器统计）
  HotSpot虚拟机提供了-XX:BackEdgeThreshold（当前虚拟机并未使用此参数），因此需要设置另外一个参数-XX:OnStackReplacePercentage来间接调整回边计数器阈值
  
  **计算公式**
  虚拟机运行在Client模式下：方法调用计数器阈值*OSR比率/100
  其中OnStackReplacePercentage默认值为933，如果都取默认值，那Client模式虚拟机回边计数器阈值为13995
  虚拟机运行在Server模式西：方法调用计数器阈值*（OSR比率-解释器监控比率）/100
  其中OnStackReplacePercentage默认值为140，InterpreterProilePercentage默认值为33，那Server模式虚拟机回边计数器阈值为10700
  
  当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否已有编译好的版本，如果有，优先执行已编译的代码，否则回边计数器加1，然后判断方法调用计数器与回边计数器之和是否超过回边计数器阈值，当超过阈值时，将提交一个OSR编译请求，并且把回边计数器值降低一些，以便在解释器中执行循环，等待编译器输出编译结果
  ![执行过程](D:\local\notes\images\OSR.bmp)
  注：回边计数器没有计数热度衰减过程（这个计数器统计的就是该方法循环执行的绝对次数）
  注：当计数器溢出时，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法时就会执行标准编译过程
  注：以上两图仅描述了Client VM的即时编译方式，对于ServerVM来说，执行情况会更复杂
  ![Java方法虚拟机内存布局](D:\local\notes\images\java-method-vm.bmp)
  注：一行长度32位
#### 编译过程
  
#### 优化技术概览（HotSpot）
  优化技术列表有不少经典编译器的优化手段，也有许多针对Java语言（准确地说是针对运行在Java虚拟机上的所有语言）本身进行的优化技术
  ![JIT编译器优化技术列表](D:\local\notes\images\JIT-optimise.bmp)
  ![JIT编译器优化技术列表1](D:\local\notes\images\JIT-optimise1.bmp)
  这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝不是建立在Java源码上的

  **方法内联**
  * 去除方法调用的成本（如建立栈帧）
  * 为其他优化建立良好的基础，方法内联膨胀之后可以便于在更大范围上采取后续的优化手段，从而获取更好地优化效果
    注：方法内联的重要性高于其他优化措施，各种编译器一般都会把内联优化放在优化序列的最靠前位置

  **冗余访问消除**
  ```java
public void foo() {
    y = b.value;
    //do stuff
    z = b.value;
    sum = y + z;
}
public void foo() {
    y = b.value;
    //do stuff
    z= y;
    sum = y + z;
}
  ```
  假设do stuff不会改变b.value的值，那么可以把`z = b.value`替换为`z = y`，这样可以不再去访问对象b的成员变量
  注：如果把b.value看做一个表达式，那可以把这项优化看成是公共子表达式消除

  **复写传播**

  ```java
public void foo() {
    y = b.value;
    //do stuff
    y = y;
    sum = y + y
}
  ```
  变量z与变量y完全相等，因此可以使用y来代替z

  **无用代码消除**

  ```java
public void foo() {
    y = b.value;
    //do stuff
    sum = y + y;
}
  ```
  无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码（Dead code）

#### 公用子表达式消除
