# <center>HTML5</center>

## Web时代的变迁

### HTML5时代即将来临

HTML5的目标：为了能够创建更简单的Web程序，书写出更简洁的HTML代码
1. HTML5提供了大量的可以替代脚本的属性标签
2. HTML5提供了更加语义化的结构标签，使得页面结构更加清晰

### HTML5会深受欢迎的理由

1. 现在的时代已经迫切地要求有一个统一的互联网通用标准
2. IE8开始支持HTML5
3. 兼容性；实用性；非革命性的发展（HTML设计原则）
4. HTML5的意图是想要把目前Web上存在的各种问题一并解决掉
    * Web浏览器之间的兼容性很低
    * 文档结构不够明确
    * Web应用程序的功能受到了限制

## HTML5与HTML4的区别

### 语法的改变

#### HTML5的语法变化

HTML的语法是在SGML语言的基础上建立起来的
HTML5地语法修改是基于现有的HTML，目的是使它运行在各浏览器时各浏览器都能符合这个通用标准

#### HTML5中的标记方法

1. HTML5的文件扩展符与内容类型保持不变。（扩展符仍然为.html或.htm；内容类型仍然为text/html）
2. DOCTYPE声明。（HTML5中不使用版本声明；不区分大小写，引号不区分单引号还是双引号）
3. 指定字符编码。（在HTML5中可以直接通过meta元素的charset属性指定字符集，不过不能与content属性混用）

#### HTML5确保了与之前HTML版本的兼容性

1. 可以省略标记的元素
    * 不允许些结束标记的元素：area base br col command embed hr img input keygen link meta param source track wbr
    * 可以省略结束标记的元素：li dt dd p rt rp optgroup option colgroup thead tbody tfoot tr td th 
    * 可以省略全部标记的元素：html head body colgroup tobody（以隐式的方式存在）
2. 具有boolean值的属性
    * 只写属性属性不写属性值代表属性为true
    * 不写属性代表属性为false
    * 属性值=属性名代表属性为ture
    * 属性值=空字符串，代表属性为ture
3. 省略引号（HTML5当属性值不包括空字符串、“<”、“>”、"="、"单引号"、“双引号”等自复式，属性值两边的引号可以省略）

### 新增元素和废除元素

#### 新增的结构元素

在HTML5中，新增了以下与结构相关的元素：
* section元素（页面中的一个内容区块，比如章节、页眉、页脚或页面中的其他部分）
* article元素（页面中的一块与上下文不相关的独立内容）
* aside元素（表示article元素的内容外的、与article元素的内容相关的辅助信息）
* header元素（表示页面中一个内容区块或整个页面的标题）
* hgroup元素（用于对整个页面或页面中一个内容区块的标题进行组合）
* footer元素（表示整个页面或页面中一个内容区块的脚注）
* nav元素（表示页面中导航链接的部分；ul标记）
* figure元素（表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元；dl标记）
* figcaption元素（为figure元素组添加标题；h1标记）

#### 新增的其他元素

* video元素（定义视频，如电影片段或其他视频流）
* audio元素（定义音频，如音乐或其他音频流）
* embed元素（用来插入多种媒体，格式可以是Midi、Wav、AIFF、AU、MP3等）
* mark元素（主要用来在视觉上向用户呈现那些需要突出显示或高亮显示的文字）
* progress元素（表示运行中的进程）
* time元素（表示日期或时间，也可以同时表示两者）
* ruby元素（表示ruby注释）
* rt元素（表示字符--中文注音或字符，的解释或发音）
* rp元素（在ruby注释中使用，以定义不支持ruby元素的浏览器所显示的内容）
* wbr元素（软换行；必要时换行）
* canvas元素（表示图形，如图表和其他图像）
* command元素（表示命令按钮，如单选按钮、复选框或按钮）
* detail元素（表示用户要求得到并且可以得到的细节信息；与summary元素配合使用）
* datalist元素（表示可选数据的列表；与Input元素配合使用）
* datagrid元素（表示可选数据列表，它以树形列表的形式来显示）
* keygen元素（表示生成秘钥）
* output元素（表示不同类型的输出，如脚本的输出）
* source元素（为媒介元素定义媒介资源）
* menu元素（表示菜单列表）

#### 新增的imput元素的类型

HTML5中新增了很多input元素的类型：
* email（表示必须输入E-mail地址的文本输入框）
* url（表示必须输入URL地址的文本输入框）
* number（表示必须输入数值的文本输入框）
* range（表示必须输入一定范围内数字值的文本输入框）
* Date Pickers（HTML5拥有多个可供选取日期和时间的新型输入文本框；date 选取日、月、年；month 选取月、年；week 选取周和年；time 选取时间小时和分钟 datetime选取时间、日、月、年UTC时间；datetime-local选取时间、日、月、年本地时间）

#### 废除的元素

1. 能用CSS替代的元素
    对于basefont、big、center、font、s、strike、tt、u这些元素，由于它们的功能都是纯粹为画面展示服务的，而HTML5中提倡把画面展示性功能放在CSS样式表中统一编辑，所以将这些元素废除了
2. 不再使用frame框架
    对于frameset元素、frame元素与noframes元素，由于frame框架对网页可用性存在负面影响，在HTML5中已不支持frame框架，只支持iframe框架，或者由服务器方创建的由多个页面组成的复合页面的形式，同时将以上这三个元素废除
3. 只有部分浏览器支持的元素
    对于applet、bgsound、blink、marquee等元素，由于只有部分浏览器支持这些元素，特别是bgsound元素以及marquee元素，只被IE支持，所以在HTML5中被废除
4. 其他被废除的元素
    废除rb元素，使用ruby元素替代；废除acronym元素，使用abbr元素替代；废除dir元素，使用ul元素替代；废除isindex元素，使用form元素与input元素相结合的方式替代；废除listing元素，使用pre元素替代；废除xmp元素，使用code元素替代；废除nextid元素，使用GUIDS替代；废除plaintext元素，使用“text/plian”MIME类型替代

### 新增的属性和废除的属性

#### 新增的属性

1. 表单相关的属性
    * 可以对input（type=text）、select、textarea与button元素指定autofous属性。它以指定属性的方式让元在画面打开时自动获得焦点
    * 可以对input元素（type=text）与textarea元素指定placeholder属性，它会对用户的输入进行提示，提示用户可以输入的内容
    * 可以对input、output、select、textarea、button与fieldset指定form属性，表明它属于哪个表单，然后将其放置在页面上任何位置，而不是表单之内
    * 可以对Input（type=text）元素与textarea元素指定required属性。该属性表示在用户提交时进行检查，检查该元素内一定要有输入内容
    * 为input元素增加了几个新的属性：autocomplete、min、max、multiple、pattern与step。同时还有一个新的list元素与datalist元素配合使用。datalist元素与autocomplete属性配合使用。multiple属性允许在上传文件时一次上传多个文件
    * 为Input元素与button元素增加了新属性formaction、formenctype、formmethod、fomnovalidate与formtarget，它们可以重载form元素的action、enctype、method、novalidate与target属性。为fieldset元素增加了diabled属性，可以把它的子元素设为disabled（无效）状态
    * 为input元素、button元素、form元素增加了novalidate属性，该属性可以取消提交进行的有关检查，表单可以被无条件地提交
2. 链接相关属性
    * 为a与area元素增加了media属性，该属性规定目标URL是为什么类型的媒介/设备进行优化的，只能在href属性存在时使用
    * 为area元素增加了hreflang属性与rel属性，以保持与a元素、link元素的一致
    * 为link元素增加了新属性sizes。该属性可以与icon元素结合使用（通过rel属性），该属性指定关联图标（icon元素）的大小
    * 为base元素增加了target属性，主要目的是保持与a元素的一致性
3. 其他属性
    * 为ol元素增加属性reversed，它指定列表倒序显示
    * 为meta元素增加charset属性
    * 为menu元素增加了两个新属性--type与label。label属性为菜单定义一个可见的标注，type属性让才当可以以上下文菜单、工具条与列表菜单三种形式出现
    * 为style元素增加scoped属性，用来规定样式的作用范围
    * 为script元素增加async顺序，它定义脚本是否异步执行
    * 为html元素增加属性manifest，开发离线Web应用程序时他与API结合使用，定义一个URL，在这个URL上描述文档的缓存信息
    * 为iframe元素增加三个属性sandbox、seamless与srcdoc，用来提高页面安全性，防止不信任的web页面执行某些操作

#### 废除的属性

HTML4中的一些属性在HTML5中不再被使用，而是采用其他属性或其他方案进行替代

### 全局属性

全局属性是指可以对任何元素都使用的属性

#### contentEditable属性

contentEditable（布尔值；有个隐藏的继承状态）是由微软开发、被其他浏览器反编译并投入应用的一个全局属性。该属性的主要功能是允许用户编辑元素中的内容，所以该元素必须是可以获得鼠标焦点的元素，而且在点击鼠标后要向用户提供一个插入符号，提示用户该元素中的内容允许编辑
另外，除了contentEditable属性外，元素还具有一个isContentEditable属性，当元素可编辑时，该属性为true；当元素不可编辑时，该属性为false

#### designMode属性

designMode属性（on与off）用来指定整个页面是否可编辑，当页面可编辑时，页面中任何支持contentEditable属性的元素都变成了可编辑状态。
designMode属性只能在JavaScript脚本里被编辑修改
针对designMode属性，各浏览器的支持情况各不相同：
* IE8：处于安全考虑，不允许使用designMode属性让页面进入编辑状态
* IE9：允许使用designMode属性让页面进入编辑状态
* Chrome3和Safari：使用内嵌frame的方式，该内嵌frame是可编辑的
* Firefox和Opera：允许使用designMode属性让页面进入编辑状态

#### hidden属性

在HTML5中，所有元素都允许使用一个hidden属性。（类似于input元素中的hidden元素；布尔值）
功能是通知浏览器不渲染该元素，使该元素处于不可见状态。但是元素中的内容还是浏览器创建的，也就是说页面装载后运行使用JavaScript脚本将该属性取消

#### spellcheck属性

spellcheck属性（布尔值；必须明确声明为true或false）是HTML5针对Input元素（type=text）与textarea这两个文本输入框提供的一个新属性，它的功能为用户输入的文本内容进行拼写和语法检查。
注：如果元素的readOnly属性或disabled属性设置为true，则不执行拼写检查；除IE之外，Firefox、Chrome、Safari、Opera等浏览器都对该属性提供了支持

#### tabindex属性

对窗口或页面中的所有控件进行遍历的时候，每一个控件的tabindex表示该控件是第几个被访问到的；默认情况下，只有链接元素与表单元素可以通过按键获得焦点。如果对其他元素使用tabindex属性后，也能让该元素获得焦点，当脚本中执行focus()语句时，就可以让该元素获得焦点（该元素也可以通过按Tab键获得焦点；可以把tabindex值设为负数-1通常）

## HTML5页面结构

### 新增的主体结构元素

内容区块：将HTML页面按逻辑进行分割后的单位

#### article元素

article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。一个article元素通常有它自己的标题（一般放在一个header元素里面），有时还有自己的脚注；article元素可以嵌套使用，内层的内容在原则上需要与外层的内容相关联

section元素是一个分块元素，用来把页面中的内容进行分块
article元素可用用来表示插件，它的作用是使插件看起来好像内嵌在页面中一样

#### section元素

section元素用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由内容及其标题组成
section元素并非一个普通的容器元素，当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section元素
在HTML5中，article元素可以看成是一种特殊种类的section元素，它比section元素更强调独立性

**关于section元素的禁忌**
* 不要将section元素用作设置样式的页面容器，那是div元素的工作
* 如果article元素、aside元素或nav元素更符合使用条件，不要使用section元素
* 不要为没有标题的内容区块使用section元素

#### nav元素

nav元素是一个可以用作页面导航的链接组，其中的导航元素链接到其他页面或当前页面的其他部分；并不是所有的链接组都要被放进nav元素，只需要将主要的、基本的链接组放进nav元素即可

**nav元素使用场合**
* 传统导航条。现在主流网站上都有不同层级的导航条，其作用是将当前画面跳转到网站的其他主要页面上去
* 侧边栏导航。现在主流博客网站及商品网站上都有侧边栏导航，其作用是将页面从当前文章或当前商品跳转到其他文章或其他商品页面上去
* 页内导航。页内导航的作用是在本页面几个主要组成部分间进行跳转
* 翻页操作。翻页操作是指在多个页面的前后页或博客网站的前后篇文章滚动

注：在HTML5中不要使用menu元素代替nav元素。menu元素是用在一系列发出命令的菜单上的，是一种交互性的元素，或者更确切地说是使用在Web应用程序中的

#### aside元素

aside元素用来表示当前页面或文章的附属信息部分，它可以包含与当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有别于主要内容的部分

**aside元素使用方法**
* 被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的参考资料、名词解释，等等。
* 在article元素之外使用，作为页面或站点全局的附属信息部分。

#### time元素与微格式

微格式是一种利用HTML的class属性来对网页添加附加信息的方法，附加信息例如新闻事件发生的日期和时间、个人电话号码、企业邮箱等。
HTML5中time元素可以无歧义地、明确地对机器的日期和时间进行编码，并且以让人易读的方式来展现它
time元素代表24小时中的某个时刻或某个日期，表示时刻时允许带时差；编码时机器读到的部分在datetime属性里，而元素的开始标记与结束标记中间的部分是显示在网页上的

注：datetime属性中日期与时间之间要用T文字分隔，T表示时间；时间加上Z文字表示给机器编码时使用UTC标准时间；加上时差表示向机器编码另一地区时间，如果是编码本地时间，则不需要添加时差

#### pubdate属性

pubdate属性是一个可选的、boolean值的属性，它可以用到article元素中的time元素上，意思是time元素代表了文章（article元素的内容）或整个网页的发布日期

### 新增的非主体结构元素

#### header元素

header元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内一个内容区块的标题，但也可以包含其他内容，例如数据表格、搜索表单或相关的logo图片
在HTML5中，一个header元素通常包括至少一个heading元素（h1-h6），也可以包括hgroup元素，还可以包括其他元素（譬如table或form）以及nav元素

#### hgroup元素

hgroup元素是将标题及其子标题进行分组的元素

#### footer元素

footer元素可以作为其上层父级内容区块或是一个根区块的脚注

#### address元素

address元素用来在文档中呈现联系信息，包括文档作者或文档维护者的名字、他们的网站链接、电子邮箱、真实地址、电话号码等。

### HTML5结构

#### 大纲

所谓大纲，简单来说就是文档中各内容区块的结构编排

1. 显式编排内容区块
显式编排是指明确使用section等元素创建文档结构，在每个内容区块使用标题（h1~h6、hgroup等）
2. 隐式编排内容区块
所谓隐式编排，是指不明确使用section等元素，而是根据页面中所书写的各级标题等把内容区块自动创建出来（HTML5分析器只要看到书写了某个级别的标题，就会判断存在相对应的内容区块）
3. 标题分级
不同的标题有不同的级别，h1的级别最高，h6的级别最低。
隐式编排自动生成内容区块规则
    * 如果新出现的标题比上一个标题级别低，生成下级内容区块
    * 如果新出现的标题比上一个标题级别高或级别相等，生成新的内容区块
4. 不同的内容区块可以使用相同级别的标题

#### 对新的结构元素使用样式

很多浏览器尚未对HTML5中新增的结构元素提供支持，需要使用CSS声明HTML5中新增元素以块方式显示

IE8及之前的浏览器不支持用CSS的方法来使用这些尚未支持的结构元素，因此需要使用JavaScript脚本生成对应dom结点再应用样式

#### article元素的样式

一个网页中可能有多个独立的article元素，每一个article元素都允许有自己的标题与脚注等从属元素，并允许对自己的从属元素单独使用样式

## 表单与文件

### 新增元素与属性

#### 新增属性

1. form属性
    form属性可以声明元素从属于指定表单；好处是当需要给页面中的元素添加样式时可以更方便地添加，因为它们不是被分散在各表单之内了；到目前为止只有Opera10浏览器支持这一属性
2. formaction属性
    在HTML5中可以给所有的提交按钮都增加不同的formaction属性，使得点击不同的按钮，可以将表单提交到不同的页面；目前没有浏览器支持这一属性
3. formmethod属性
    在HTMML5中，可以使用formmethod属性来对每个表单元素分别指定不同的提交方法；目前没有浏览器支持该属性
4. placeholder属性
    placeholder是指当文本框处于未输入状态时文本框中显示的输入提示；目前为止，支持该属性的浏览器有：Safari4、Google Chorme3、Firefox4
5. autofocus属性
    给文本框、选择框或按钮控件加上该属性，当画面打开时，该控件自动获得光标焦点；一个页面上只能有一个控件具有该属性；当有一个页面是以使用某个控件为主要目的时，才对该控件使用autofocus属性；支持该属性的浏览器有：Safari4、Google Chorme3、Firefox4
6. list属性
    在HTML5中，为单行文本框增加了一个list属性，该属性为某个datalist元素的id（可输入下拉框）；目前只有Opera10浏览器支持list属性
7. autocomplete属性
    辅助输入所用的自动完成功能，是一个节省输入时间，同时也十分方便的功能；目前为止，只有Opera10浏览器支持autocomplete属性

#### 大幅度地增加与改良了input元素的种类

对于不支持新增input元素的浏览器来说，统一将这些input元素视为text类型；HTML5中没有规定这些元素在各浏览器中的外观形式

**增加与改良的input元素**
种类：search tel url email datetime;date;month;week;time;datetime-local number range color file（可以通过指定multiple属性，一次选择多个文件；可以通过指定accept属性限制选择文件的种类）
1. url类型
    url类型的input元素是一种专门用来输入url地址的文本框
2. email类型
    email类型的input元素是一种专门用来输入email地址的文本框（不检查是否存在，只检查是否合法）
3. date类型
    date类型的input元素以日历的形式方便用户输入
4. time类型
    time类型的input元素是一种专门用来输入时间的文本框，并且在提交时会对输入时间的有效性进行检查
5. datetime类型
    datetime类型的input元素是一种专门用来输入UTC日期和时间的文本框，并且在提交时会对输入的日期和时间进行有效性检查
6. datetime-local类型
    datetime-local类型的input元素是一种专门用来输入本地日期和时间的文本框，并且在提交时会对输入的日期和时间进行有效性检查
7. month类型
    month类型的input元素是一种专门用来输入月份的文本框，并且在提交时会对衰弱的月份的有效性进行检查
8. week类型
    week类型的input元素是一种专门用来输入周号的文本框，并且在提交时会对输入的周号之有效性进行检查
9. number类型
    number类型的input元素是一种专门用来输入数字的文本框，并且在提交时会检查其中的内容是否为数字
10. range类型
    range类型的input元素是一种只允许输入一段范围数值的文本框
11. search类型
    search类型的input元素是一种专门用来输入搜索关键字的文本框
12. tel类型
    tel类型的input元素被设计为用来输入电话号码的专用文本框；开发者可以通过pattern属性来指定对于输入的电话号码格式的验证
13. color类型
    color类型的input元素用来选取颜色，它提供了一个颜色选取器

#### 对新的表单元素使用样式

到目前为止，还没有可以针对新元素的局部区域进行修改的样式

#### output元素的追加

在HTML5中，追加了新的元素output。output元素定义不同类型的输出，比如计算结果或脚本的输出；必须从属于某个表单；目前该元素只被Opera10浏览器支持

### 表单验证

提交时对表单与表单内新增元素进行内容有效性验证

#### 自动验证

在HTML5中，通过对元素使用属性的方法，可以实现在表单提交时执行自动验证的功能

**对元素输入内容进行限制的属性的指定**
1. required属性
    HTML5中新增的required属性可以应用在大多数输入元素上（除了隐藏元素、图片元素按钮上）。在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示信息提示文字，提示用户这个元素中必须输入内容
2. pattern属性
    对input元素使用pattern属性，并且将属性值设为某个格式的正则表达式，在提交时会检查其内容是否符合给定格式
3. min属性与max属性
    min与max这两个属性是数值类型或日期类型的Input元素的专用属性，它们限制了input元素中输入的数值与日期的范围
4. step属性
    step属性控制input元素中的值增加或减少时的步幅

#### 显示验证

在HTML5中，form元素与input元素（包括select元素与textarea元素）都具有一个checkValidity方法。调用该方法，可以显示地对表单内所有元素内容或单个元素内容进行有效性验证
在HTML5中，form元素与input元素都还存在一个validity属性，该属性返回一个ValidityState对象，该对象具有valid属性。该属性表示了表单内所有元素内容是否有效或单个元素内容是否有效

#### 取消验证

1. 利用form元素的novalidate属性，它可以关闭整个表单验证
2. 利用input元素或submit元素的formnovalidate属性

利用这一点可以实现“假提交”与“真提交”的效果

#### 自定义错误信息

在HTML5中，可以使用Javascript调用各input元素setCustomValidity方法来自定义错误信息；Opera是目前唯一支持自定义错误信息提示的浏览器

### 增强的页面元素

#### 新增的figure元素与figcaption元素

figure元素也是一种元素的组合，带有可选标题；figure元素用来表示网页上一块独立的内容，将其从网页上移除后不会对网页上的其他内容产生任何影响；figure元素所表示的内容可以是图片、统计图或代码示例
figcaption元素表示figure元素的标题，它从属于figure元素，必须书写在figure元素内部，可以书写在figure元素内的其他从属元素的前面或后面；一个figure元素内最多只允许放置一个figcaption元素，但允许放置多个其他元素

#### 新增的details元素

details元素提供了一种替代Javascript的、将画面上局部区域进行展开或收缩的方法；现在还没有任何浏览器对它提供支持；open属性表示在画面打开时details元素所表示的局部区域则会处于展开状态
summary元素从属于details元素，用鼠标点击summary元素中的内容文字时，details元素中的其他所有从属元素将会展开或收缩；如果details元素内没有summary元素，浏览器会提供默认文字以供点击

#### 新增的mark元素

mark元素表示页面中需要突出显示或高亮显示的，对于当前用户具有参考作用的一段文字；mark元素最主要的目的是吸引当前用户的注意
mark元素的标示目的与原文作者无关；strong是原文作者用来强调一段文字的重要性；em元素作者为了突出文章重点使用的

#### 新增的progress元素

progress代表一个任务的完成进度，这个进度可以是不确定的，只是表示进度正在进行，但不清楚还有多少工作量没有完成，也可以用0到某个最大数字之间的数字来表示准确的进度完成情况
value属性表示已经完成了多少工作量，max属性表示总共有多少工作量；工作量单位是随意的，不用指定

#### 新增的meter元素

meter元素表示规定范围内的数量值。例如，磁盘使用量，对某个候选者的投票人数占总投票人数的比例等。

**meter元素属性**
* value：在元素中特地表示出来的实际值；默认值为0，可以指定一个浮点小数值
* min：指定规定的范围时允许使用的最小值；默认为0，不能小于0
* max：指定规定的范围时允许使用的最大值；如果设定时该属性值小于min属性的值，那么把min属性的值视为最大值；max属性的默认值为1
* low：规定范围的下限值；必须小于或等于high属性的值；如果low属性值小于min属性的值，那么把min属性的值视为low属性的值
* high：规定范围的上限值；如果high属性值小于low属性的值，那么把low属性的值视为high属性的值;如果high属性值大于max属性的值，那么把max属性的值视为high属性的值
* optimum：最佳值，属性值必须在min属性值与max属性值之间，可以大于high属性值

#### 新增menu元素和command元素

menu和command元素是HTML5中新增的用于Web应用程序的元素，它用于菜单、工具条及弹出菜单；menu元素相当于其他语言开发工具中的菜单，而command元素相当于其他开发语言工具中的菜单项；目前尚未有任何浏览器支持这两个元素

#### 改良的ol列表

在HTML5中，将ol列表进行了改良，为它添加了start属性（自定义编号的初始值）与reserved属性；目前还没有任何浏览器对reserved属性提供支持

#### 改良的dl列表

术语与名词解释是多对多的关系
dfn元素用于标记术语

#### 加以严格限制的cite元素

cite元素表示作品的标题；HTML5中明确规定了不能用cite元素表示包括作者在内的任何人民

#### 重新定义的small元素

在HTML5中，对small元素进行了重新定义，使其由原来的通用展示性元素变为更具体的、专门用来标识所谓“小字印刷体”的元素；不允许被应用在页面主内容中，只允许被当做辅助信息用inline方式内嵌在页面上使用；small元素不意味着元素中内容字体会变小，如果需要将字体变小，需要配合着CSS样式表来使用

### 文件API

#### FileList对象与file对象

FileList对象表示用户选择的文件列表；在HTML5中，通过添加multiple属性，file控件内允许一次放置多个文件
file对象属性：name属性表示文件名，不包括路径；lastModifiedDate属性表示文件的最后修改日期

#### Blob对象

Blob表示二进制原始数据，它提供了一个slice方法，可以通过该方法访问到字节内部的原始数据块（file对象也继承了Blob对象）
Blob对象属性：size表示一个Blob对象的字节长度；type属性表示Blob对象的MIME类型
在HTML5中已经对file控件添加了accept属性，企图让file控件只能接受某种类型的文件，但是目前各主流浏览器对其的支持都只限于在打开文件选择窗口时，默认选择指定文件而已，如果选择其他类型文件，file控件也能正常接受

#### FileReader接口

FileReader接口主要用来把文件读入内存，并且读取文件中的数据；FileReader接口提供了一个异步API；目前为止，只有Firefox3.6+和Google Chorme6.0+实现了FileReader接口

**FileReader接口的方法**
* readAsText：该方法有两个参数，其中第二个参数是文本的编码方式，默认值为UTF-8
* readAsBinaryString：这个方法将文件读取为二进制字符串，通常将它传送到后端，后端可以通过这段字符串存储文件
* readAsDataURL：该方法将文件读取为一串Data URL字符串，该方法事实上是将小文件以一种特殊格式的URL地址形式直接读入页面。（小文件通常是指图像与html等格式的文件）
* abort：中断读取操作

**FileReader接口的事件**
FileReader接口还包含一套完整的事件模型，用于捕获读取文件时的状态
onabort 读取中断 onerror 读取出错 onloadstart 读取开始 onprogress 读取中 onload 读取成功 onloadend 读取完成无论成功失败

### 拖放API

在HTML5之前已经可以使用mousedown、mousemove、mouseup来实现拖放操作，但是这只支持在浏览器内部的拖放，在HTML5中，已经支持在浏览器与其他应用程序之间的数据相互拖动

#### 实现拖放的步骤

1. 将想要拖放的对象元素的draggable属性设为ture。另外img元素与a元素默认允许拖放
2. 编写与拖放有关的事件处理代码

**拖放相关事件**
dragstart 拖放开始 drag拖放过程中 dragenter 被拖放的元素进入本元素 dragover 被拖放的元素正在本元素范围内移动 dragleave 被拖放的元素离开本元素的范围 drop 有其他元素被拖放到了本元素中 dragend 拖放操作结束

DataTransfer对象专门用来存放拖放时要携带的数据；如果把setDate第二参数改为this.id，所携带的数据就是被拖动元素中的数据了

现在支持拖动处理的MIME类型：text/plain text/html text/xml text/uri-list

#### Datatransfer对象的属性与方法

**设定拖放时的视觉效果**
dropEffect属性与effectAllowed属性结合起来可以设定拖放时的视觉效果
effectAllowed属性表示当一个元素被拖动时所允许的视觉效果，一般在ondragstart中指定，所允许的值为nono、copy、copyLink、copyMove、link、linkMove、move、all、unintialize
dropEffect属性表示实际拖放时的效果，一般在ondragover事件中指定，允许设定的值为none、copy、link、move
dorpEffect属性所表示的实际视觉效果必须在effectAllowed属性所表示的允许的视觉效果范围内

**规则**
1. 如果effectAllowed属性设定为none，则不允许拖放元素
2. 如果dorpEffect属性设定为none则不允许被拖放到目标元素中
3. 如果effectAllowed属性设定为all或不设定，则dorpEffect属性允许被设定为任何值，并且按指定视觉效果进行显示
4. 如果effectAllowed设定为具体效果（不为none、all），dorpEffect属性也设定了具体视觉效果，则两个具体效果值必须完全相等，否则不允许将被拖放元素拖放到目标元素中

**自定义拖放图标**
HTML5中允许自定义拖放图标--指的是在用鼠标拖动元素的过程中，位于鼠标指针下部的小图标
DataTransfer对象setDragImage方法，第一参数image设定为拖放图标的图标元素，第二个参数x为拖放图标离鼠标指针x轴方向的位移量，第三个参数y为拖放图标离鼠标指针的y轴方向的位移量

## 绘制图形

### canvas元素的基础知识

canvas元素是HTML5中新增的一个重要元素，专门用来绘制图形；canvas元素只是一块无色透明的区域，需要利用JavaScript编写在其中进行绘画的脚本

#### 在页面中放置canvas元素

指定ID、width、height三个属性

#### 绘制矩形

用canvas元素绘制图形步骤
1. 取得canvas元素
2. 取得上下文（canvas.getContext）
3. 填充与绘制边框
4. 设定绘图样式（填充图形样式；图形边框样式）
5. 指定线宽
6. 指定颜色值
7. 绘制矩形
可以使用clearRect方法使矩形区域中颜色全部变为透明

### 使用路径

#### 绘制圆形

要想绘制其他图形，需要使用路径，在获得图形上下文后，执行以下步骤：
* 开始创建路径（context.beginPath）
* 创建图形的路径
* 路径创建完成后，关闭路径（context.closePath）
* 设定绘制样式，调用绘制方法，绘制路径

如果没有关闭路径，即便在页面上将图形绘制完毕，已经创建的路径会永远保留；在进行绘制时，要仔细计算好路径从哪里开始，在哪里关闭

#### moveTo与lineTo

绘制直线时，一般会用到moveTo与lineTo两种方法
* moveTo方法的作用是将光标移动到指定坐标点，，绘制直线时以这个坐标点为起点
* lineTo方法在moveTo方法中指定的直线起点与参数中指定的直线终点间绘制一条直线，光标会自动移动到lineTo方法的参数所指定的直线终点

#### 使用bezierCurveTo绘制贝济埃曲线

beizerCurveTo中第一二个参数分别为第一个控制点横坐标和纵坐标，第三四个参数分别为第二个控制点横坐标和纵坐标，第五六个参数分别为终点横坐标和纵坐标
quadraticCurveTo可以绘制二次样条曲线，只有一个控制点，需要四个参数

### 绘制渐变图形

#### 绘制线性渐变

fillStyle除了指定颜色之外，还可以用来指定填充的对象
渐变是指填充时从一中颜色慢慢过渡到另外一种颜色

使用context.createLinearGradient方法创建LinearGradient（线性渐变）；使用context.addColorStop设定线性渐变颜色，第一个参数为设定颜色离开渐变起点的偏移量

#### 绘制径向渐变

径向渐变是指沿着圆形的半径方向向外进行扩散的渐变方式

使用createRadialGradient方法绘制径向渐变；这个方法分别指定了两个圆的大小与位置，从第一个圆的圆心处向外进行扩散渐变，一直扩散到第二个圆的外轮廓处

### 绘制变形图形

#### 坐标变换

**坐标变换的三种方式**
* 平移：使用图形上下文对象的translate方法移动坐标轴原点；x表示将坐标轴原点向右移动多少个单位，y表示将坐标轴原点向下移动多少个单位
* 扩大：使用图形上下文对象的scale方法将图形放大；x是水平放大倍数，y是垂直方向的放大倍数
* 旋转：使用图形上下文对象的rotate方法将图形进行旋转：接收一个角度参数，旋转中心点是坐标轴的原点，以顺时针方向进行，逆时针将角度设定为负数

#### 坐标变换与路径的结合使用

另写一个创建路径的函数，然后在坐标变换的同时调用该函数

#### 矩阵变换

变换矩阵是专门用来实现图形变形的，它与坐标一起配合使用，以达到变形的目的。当图形上下文被创建完毕时，事实上也创建了一个默认的变换矩阵

使用图形上下文对象的transform方法修改变换矩阵；该方法使用一个新的变换矩阵与当前变换矩阵进行乘法运算；前面四个参数控制缩放，后面两个参数控制平移

**transform工作原理**
坐标变换都是隐式地修改了变换矩阵，都可以使用transform方法来代替

### 图形组合

使用Canvas API可以将一个图形重叠绘制在另一个图形上面，但图形中能够被看到的部分完全取决于图形的绘制顺序

在HTML5中，可以使用图形上下文对象到的globalCompositeOperation属性来自己决定图形的组合方式；context.globalCompositeOperation=type

**type的值**
1. source-cover（默认值），表示新图像覆盖在原有图形之上
2. destination-over，表示在原有图形之下绘制新图形
3. source-in，新图形与原有图形作in运算，只显示新图形中与原有图形相重叠的部分，新图形与原有图形的其他部分均变成透明
4. destination-in，原有图形与新图形作in运算，只显示原有图形中与新图形相重叠的部分，新图形与原有图形的其他部分均变成透明
5. source-out，新图形与原有图形作out运算，只显示新图形中与原有图形不重叠的部分，新图形与原有图形的其他部分均变成透明
6. destination-out，原有图形与新图形作out运算，只显示原有图形中与新图形不重叠的部分，新图形与原有图形的其他部分均变成透明
7. source-atop，只绘制新图形中与原有图形重叠部分与未被重叠覆盖的原有图形，新图形的其他部分变成透明
8. destination-atop，只绘制原有图形中被新图形重叠覆盖的部分与新图形的其他部分，原有图形中的其他部分变成透明，不会只新图形中与原有图形相重叠的部分
9. lighter，原有图形与新图形均绘制，重叠部分做加色处理
10. xor，只绘制新图形中与原有图形不重叠的部分，重叠部分变成透明
11. copy，只绘制新图形，原有图形中未与新图形重叠的部分变成透明
注：如果指定的type不在这几个字符串当中，则按默认方式组合图形

### 给图形绘制阴影

在HTML5中，使用Canvas元素可以给图形添加阴影效果

**阴影绘制的属性**
1. shadowOffsetX，阴影的横向位移量
2. shadowOffsetY，阴影的纵向位移量
3. shadowColor，阴影的颜色
4. shadowBlur，阴影的模糊范围
shadowOffsetX与shadowOffsetY所代表的阴影横向位移量与纵向位移量是指图像向横向方向移动，或纵向方向移动以产生阴影效果时的移动距离。默认值为0；shadowBlur表示图形阴影边缘的模糊范围，如果不希望阴影的边缘太清晰，需要将阴影的边缘模糊化时可以使用该属性。一般设定在0至10之间
注：通过设置阴影颜色可以控制是否具有阴影效果，如设置为rgba(0,0,0,0)

### 使用图像

#### 绘制图像

在HTML5中，不仅可以使用过Canvas API来绘制图形，还可以读取磁盘或网络中的图像文件，然后使用Canvas API将该图像绘制在画布中

绘制图像时，使用drawImage方法；在Image对象的onload事件中同步执行绘制图像的函数，就可以一边装载一边绘制了

#### 图像平铺

图像平铺指的是按一定比例缩小后的图像将画布填满

**实现方式**
* 使用drawImage方法
* 使用图形上下文对象的createPattern方法

createPattern的第二个参数：no-repeat不平铺；repeat-x横向平铺；repeat-y纵向平铺；repeat全方向平铺

#### 图像裁剪

Canvas API的图像裁剪功能指，在画布内使用路径，只绘制路径所包括区域内的图像，不绘制路径外部的图像；使用图形上下文对象的不带参数的clip方法来实现Canvas元素的图像裁剪功能

可以使用绘制状态的保存与恢复功能来取消掉已经设置好的裁剪区域

#### 像素处理

使用Canvas API能够获取图像中的每一个像素，然后得到该像素颜色的rgb值或rgba值；使用图形上下文对象的getImageData方法来获取图像中的像素

#### 绘制文字

**图形上下文对象有关文字绘制的属性**
* font属性：设置文字字体
* textAlign属性：设置文字水平对齐方式
* textBaseline属性；设置文字垂直对齐方式

可以使用图形上下文对象的measureText方法来得到文字的宽度

### 补充知识

#### 保存与恢复状态

Canvas API中的save与restore两个方法可以保存与恢复图形上下文的当前绘画状态；这里的绘画状态指坐标原点、变形时的变换矩阵，以及图形上下文对象的当前属性值等很多内容

#### 保存文件

Canvas API保存文件的原理实际上是把当前的绘画状态输出到一个data URL地址所指向的数据中的过程

data URL是指目前大多数浏览器能够识别的一种base64位编码的URL，主要用于小型的、可以在网页中直接嵌入，而不需要从外部文件嵌入的数据

Canvas API使用toDataURL方法把绘画状态输出到一个data URL中，然后重新装载，客户可直接把装载后的文件进行保存；其参数表示要输出数据的MIME类型

#### 简单动画的制作

在Canvas画布中制作动画实际上是一个不断擦除、重绘的过程

**步骤**
1. 预先编号用来绘图的函数，在该函数中先用clearRect方法将画布整体或局部擦除
2. 使用setInterval方法设置动画的间隔时间

## 多媒体播放

### video元素与audio元素的基础知识

#### HTML4页面中播放视频或音频的方法

需要结合使用比较复杂的object元素与embed元素；用户需要安装Flash插件

#### HTML5页面中播放视频或音频的方法

只需要为audio元素指定src以及为video元素设定长、宽和src等属性

还可以通过source元素来为同一个媒体数据指定多个播放格式与编码方式；最好不要省略type属性，否则浏览器会在从上往下选择时无法判断自己能不能播放而先行下载一小段视频或音频数据，这样就有可能浪费带宽和时间

### 属性

* src，指定媒体数据的URL地址
* autoplay，指定媒体是否在页面加载后自动播放
* preload，指定视频或音频数据是否预加载。如果使用预加载，浏览器会预先将视频或音频数据进行缓冲，这样可以加快播放速度，因为播放时数据已经预先缓冲完毕；none表示不进行预加载，metadata表示只加载媒体的元数据，auto表示预加载全部视频或音频，默认值为auto
* poster，video元素独有属性，当视频不可用时，可以向用户展示一幅替代用的图片
* loop，指定是否循环播放视频或音频
* controls，指定是否为视频或音频添加浏览器自带的播放用的控制条
* width与hight，video元素独有属性，指定视频的宽度与高度
* error属性，在读取、使用媒体数据的过程中，任何时候只要出现错误，error属性将返回一个MediaError对象，该对象的code返回对应的错误状态；MEDIA_ERR_ABORTED(1)：媒体数据的下载过程中由于用户的操作原因而被中止，MEDIA_ERR_NETWORK(2)：确认媒体资源可用，但是在下载时出现网络错误，媒体数据的下载过程被中止，MEDIA_ERR_DECODE(3)：确认媒体资源可用，但是解码时发生错误，MEDIA_ERR_SRC_NOT_SUPPORTED(4)：媒体格式不被支持；error属性为只读属性
* networkState属性，读取当前网络状态；NETWORK_EMPTY(0)：元素处于初始状态，NETWORK_IDLE(1)：浏览器已选择好用什么编码格式来播放媒体，但尚未建立网络连接，NETWORK_LOADING(2)：媒体数据加载中，NETWORK_NO_SOURCE：没有支持的编码格式，不执行加载；networkState属性为只读属性
* currentSrc属性，读取播放中的媒体数据的URL地址；currentSrc属性为只读属性
* buffered属性，可以使用video元素或audio元素的buffered属性返回一个对象，该对象实现TimeRanges接口，以确认浏览器是否已缓存媒体数据；buffered属性为只读属性
* readyState属性，返回媒体当前播放位置的就绪状态；HAVE_NOTHING(0)：没有获取到媒体任何信息，当前播放位置没有可播放数据，HAVE_METADATA(1)：已经获取到了足够的媒体数据，但是当前播放位置没有有效的媒体数据，HAVE_CURRENT_DATA(2)：当前播放位置已经有数据可以播放，但是没有获取到可以让播放器前进的数据，HAVE_FUTURE_DATA(3)：当前播放位置已经有数据可以播放，而且也获取到了可以让播放器前进的数据，HAVE_ENOUGH_DATA(4)：当前播放位置已经有数据可以播放，同时也获取到了可以让播放器前进的数据，而且浏览器确认媒体数据以某一种速度进行加载，可以保证有足够的后续数据进行播放；readyState属性为只读属性
* seeking属性与seekable属性，seeking属性表示浏览器是否正在请求某一特定播放位置的数据；可以使用seekable属性来返回一个TimeRanges对象，该对象表示请求到的数据的时间范围；均为只读属性
* currentTime属性、startTime属性与duration属性，currentTime读取媒体的当前播放位置，可修改，如果修改的位置上没有可用的媒体数据时，将抛出INVALID_STATE_ERR异常，如果修改的位置超出了浏览器在一次请求中可以请求的数据范围，将抛出INDEX_SIZE_ERR异常；startTime读取媒体播放的开始时间，通常为0；duration属性读取媒体文件总的播放时间；单位为秒，后两者为只读属性
* played属性、paused属性、ended属性，palyed顺序返回一个TimeRanges对象，可以读取媒体文件已播放部分的时间段；paused属性表示是否处于暂停播放；ended属性表示是否播放完毕；三者均为只读属性
* defaultPlaybackRate属性与playbackRate属性，前者读取或修改媒体默认的播放速率，后者读取或修改媒体当前的播放速率
* volume属性与muted属性，前者读取或修改媒体的播放音量，范围0到1；后者读取或修改媒体的静音状态

### 方法

* play，使用play方法来播放媒体，自动将元素的paused属性的值变为false
* pause方法，使用pause方法来暂停播放，自动将元素的paused属性的值变为true
* load方法，使用load方法来重新载入媒体进行播放，自动将元素的playbackRate属性值变为defalutPlaybackRate属性的值，自动将元素的error的值变为null
* canPlayType方法，使用canPlayType方法来测试浏览器是否支持指定的媒体类型；空字符串表示浏览器不支持此种媒体类型，maybe表示浏览器可能支持此种媒体类型，probably表示浏览器确定支持此种媒体类型

### 事件

#### 事件处理方式

**事件的捕捉及其处理**
* 监听的方式
* JavaScript脚本中常见的获取事件句柄的方式

#### 事件介绍

loadstart浏览器开始在网上寻找媒体数据 progress浏览器正在获取媒体数据 suspend浏览器暂停获取媒体数据，但是下载过程并没有正常结束 abort浏览器在下载完全部媒体数据之前终止获取媒体数据，但是并不是由错误引起的 error获取媒体数据过程中出错 emptied所在网络突然变为未初始化状态（载入媒体过程中突然发生一个致命错误；浏览器正在选择支持的播放格式时，又调用了load方法重新载入媒体）stalled浏览器尝试获取媒体数据失败 play即将开始播放 pause播放暂停 loadedmetadata浏览器获取完毕媒体的时间长和字节数 waiting 播放过程由于得不到下一帧而暂停播放，但很快就能够得到下一帧 playing正在播放 canplay浏览器能够播放媒体，但估计以当前播放速率不能直接将媒体播放完毕，播放期间需要缓冲 canplaythrough浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要缓冲 seekingseeking属性变为true，浏览器正在请求数据 seekedseeking属性变为false浏览器停止请求数据 timeupdate当前播放位置被改变 ended播放结束后停止播放 ratechangedefaultplaybackRate属性或playbackRate属性被改变 duration播放时长被改变 volumechangevolume属性被改变后muted属性被改变

## 本地存储

### Web Storage

#### Web Storage是什么

**cookies的限制**
* 大小：cookies的大小被限制在4KB
* 带宽：cookies是随HTTP事务一起被发送的，因此会浪费一部分发送cookies时使用的带宽
* 复杂性：要正确地操纵cookies是很困难的

Web Storage就是在Web上储存数据的功能，这里的储存，是针对客户端本地而言的

**Web Storage分两种**
* sessionStorage
  将数据保存在session对象中。session是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求的保存的任何数据
* localStorage
  将数据保存在客户端本地的硬件设备（通常指硬盘，但也可以是其他硬件设备）中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用（数据保存是按不同的浏览器分别进行的）
  

使用setItem保存，使用getItem读取；保存时不允许重复保存相同的键名，保存后可以修改键值，但不允许修改键名（只能重新取键名，然后再保存键值）

### 本地数据库

#### 本地数据库的基本概念

在HTML5中内置了一个可以通过SQL语言来访问的数据库；不需要存储在服务器上的文件SQL数据库称为SQLLite

**使用SQLLite数据库**
1. 创建访问数据库的对象
2. 使用事务处理

使用openDatabase方法来创建一个访问数据的对象；如果数据库不存在，则创建该数据库；实际访问数据库时，还需要调用transaction方法，用来执行事务处理，事务可以达到在操作完了之前，阻止别的用户访问数据库的目的

#### 用executeSql来执行查询

transaction对象的executeSql方法第一个参数为需要执行的SQL语句，第二个参数为SQL语句中所有使用到的参数的数组，第三个参数为执行sql语句成功时调用的回调函数，第四个参数为SQL语句出错时调用的回调函数

## 离线应用程序

### 离线Web应用程序详解

#### 新增的本地缓存

为了让Web应用程序在离线状态时也能正常工作，就必须把所有构成Web应用程序的资源文件放在本地缓存中，当服务器没有和Internet建立连接时，也可以利用本地缓存中的资源文件来正常运行Web应用程序

#### 本地缓存与浏览器网页缓存的区别

* 本地缓存是为整个Web应用程序服务的，而浏览器的网页缓存只服务于当个网页；任何网页都具有网页缓存，而本地缓存只缓存哪些你指定缓存的网页
* 网页缓存时不安全、不可靠的，因为我们不知道在网站中到底缓存了哪些网页，以及缓存了网页上的哪些资源，而本地缓存是可靠的，我们可以控制对哪些内容进行缓存，不对哪些内容进行缓存

### manifest文件

Web应用程序的本地缓存是通过每个页面的manifest文件来管理的

真正运行或测试离线Web应用程序时，需要对服务器进行配置，让服务器支持text/cache-manifest这个MIME类型

**资源文件分为三类**
* CACHE指定需要被缓存在本地的资源文件；如果一个页面具有manifest文件，浏览器会自动对这个页面进行本地缓存
* NETWORK显式指定不进行本地缓存的资源文件；通配符 * 表示没有在本manifest文件中指定的资源文件都不进行本地缓存
* FALLBACK类别中每行指定两个资源文件，第一个资源文件为能够在在线访问时使用的资源，第二个资源文件为不能在线访问时的备用资源文件

为了让浏览器能够正常阅读该文本文件，需要在Web应用程序页面上的html标签的manifest属性中指定manifest文件的URL地址

当要对本地缓存中的内容进行修改时，只要修改manifest文件就可以了。文件被修改后，浏览器可以自动检查manfiest文件，并自动更新本地缓存中的内容

### 浏览器与服务器的交互过程

**首次访问网站**
1. 访问网站
2. 服务器返回首页
3. 浏览器解析首页，请求页面上所有资源
4. 服务器返回所有资源文件
5. 浏览器处理manifest文件，请求manifest中所有要求本地缓存的文件
6. 服务器返回所有要求本地缓存的文件
7. 浏览器对本地你缓存进行更新，并触发一个时间，通知本地缓存被更新

**再次打开网站，且manifest文件没有被修改过**
1. 浏览器再次请求访问网站
2. 浏览器发现首页被缓存，于是使用本地缓存中首页
3. 浏览器解析首页，使用所有本地缓存中的资源文件
4. 浏览器向服务器请求manifest文件
5. 服务器返回一个304代码，通知浏览器manifest没有发生变化

只要页面上的资源文件被本地缓存过，下次浏览器打开这个页面时，总是先使用本地缓存中的资源，然后请求manifest文件

**再次打开网站，且manifest文件被修改**
1. 浏览器再次请求访问网站
2. 浏览器发现首页被缓存，于是使用本地缓存中首页
3. 浏览器解析首页，使用所有本地缓存中的资源文件
4. 浏览器向服务器请求manifest文件
5. 服务器返回更新过的manifest文件
6. 浏览器处理manifest文件，发现改文件已被更新，于是请求所有要求进行本地缓存的资源文件，包括首页
7. 服务器返回要求进行本地缓存的资源文件
8. 浏览器对本地缓存进行更新，并触发一个事件，通知本地缓存被更新

### applicationCache对象

applicationCahce对象代表了本地缓存，可以用它来通知用户本地你缓存中资源已经被更新，也允许用户手工更新本地缓存

当浏览器对本地缓存进行更新，装入新的资源文件时，会触发applicationCache对象的updateready事件，通知本地缓存已被更新。可以利用这个事件告诉用户本地缓存已经被更新，用户需要手工刷新页面来得到最新版本的应用程序

可以通过applicationCache的swapCache方法来控制如何进行本地缓存的更新及更新时机

#### swapCache方法

swapCache方法用来手工执行本地缓存的更新，它只能在applicationCache对象的updateReady事件被触发时调用；updateReady事件只有在服务器上的manifest文件被更新，并且把manifest文件所要求的资源文件下载到本地后触发

如果本地缓存的容量非常大（譬如超过100MB），本地缓存的更新工作将需要相对较长的时间，而且还会把浏览器个锁住

不调用swapCache方法，本地缓存将在下一次打开本页面时被更新；如果调用swapCahce方法的话，本地缓存将会被立刻更新；可以使用confirm方法让用户自己选择更新时机；applicationCache.update方法的作用是检查服务器上的manifest文件是否有更新

#### applicationCache对象的事件

**首次访问**
浏览器发现网页具有manifest属性，会触发checking事件，检查manifest文件是否存在。不存在时，触发error事件，表示manifest文件未找到；服务器返回所有要求本地缓存的文件，浏览器会触发downloading事件，然后开始下载这些资源，在下载的同时，周期性地触发progress事件，开发人员可以用编程手段获取多少文件已被下载，多少文件仍然处于下载队列等信息；下载结束后触发chached事件，表示首次缓存成功，存入所有要求本地缓存的资源文件

**再次访问**
浏览器核对manifest文件是否被更新，若没有被更新，触发noupdate事件；如果被更新，不触发cached事件，而是触发updateready事件，表示下载结束，可以通过刷新页面来使用更新后的本地缓存，或调用swapCache方法来立刻使用更新后的本地缓存

在访问缓存名单时如果返回一个HTTP404错误（页面未找到），或者410错误（永久消失），则触发obsolete事件；在整个过程中，如果任何与本地缓存有关的处理中发生错误的话，都会触发error事件

**触发error事件的情况**
* 缓存名单返回一个HTTP404错误（页面未找到），或者410错误（永久消失）
* 缓存名单被找到且没有更改，但是引用缓存名单的HTML页面不能正确下载
* 缓存名单被找到且被更改，但浏览器不能下载某个缓存名单中列出的资源
* 开始更新本地缓存时，缓存名单再次被更改

## 通信API

### 跨文档消息传输

#### 跨文档消息传输的基本知识

HTML5提供了网页文档之间互相接收与发送信息的功能。使用这个功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的Web网页之间可以互相通信，甚至可以实现跨域通信

要想接受从其他窗口那里发过来的消息，就必须对窗口对象的message事件进行监视；使用window对象的postMessage方法向其他窗口发送消息

### Web Sockets通信

#### Web Sockets通信的基本知识

Web Sockets是HTML5提供的在Web应用程序中客户端与服务器端之间进行的非HTTP的通信机制

#### 使用Web Sockets API

Web Sockets API将URL字符串作为参数，然后调用WebSocket对象的构造器来建立与服务器之间的通信连接；URL字符串必须以ws或wss（加密通信时）文字作为开头

使用WebSocket对象的send方法对服务器发送数据，只能发送文本数据，但是可以使用JSON对象把任何JavaScript对象转成文本数据后进行发送；通过onmessage事件句柄来接收服务器传来的数据；通过获取onopen事件句柄来监听socket的打开事件；通过获取onclose事件句柄来监听socket的关闭事件；通过close方法来关闭socket，切断通信连接

可以通过readyState的属性值来获取WebSocket对象的状态
* CONNECTIONG(0)，表示正在连接
* OPEN(1)，表示已建立连接
* CLOSING(2)，表示正在关闭连接
* CLOSED(3)，表示已关闭连接

## 使用Web Workers处理线程

### 基础知识

Web Workers是在HTML5中新增的，用来在Web应用程序中实现后台处理的一项技术

创建后台线程的步骤十分简单。只要在Worker类的构造器中，将需要在后台线程中执行的脚本文件的URL地址作为参数，然后创建Worker对象就可以了
注：在后台线程中不能访问页面或窗口对象
另外，可以通过发送和接收消息来与后台线程互相传递数据；可以通过Worker对象的onmessage事件句柄及Worker对象的postMessage方法

### 线程嵌套

线程中可以嵌套子线程，这样可以把一个较大的后台线程切分成几个子线程，每个子线程中各自完成相对独立的一部分工作

#### 单层嵌套

在子线程中向发送源发送回消息后，最好使用close语句关闭子线程，如果该子线程不再使用的话

#### 在多个子线程中进行数据的交互

* 先创建发送数据的子线程
* 执行子线程中的任务，然后把要传递的数据发送给主线程
* 在主线程接受到子线程传回来的消息时，创建接收数据的子线程，然后把发送数据的子线程中返回的消息传递个接收数据的子线程
* 执行接收数据子线程中的代码

#### 线程中可用的变量、函数与类

* self，用来表示本线程范围内的作用域
* postMessage，向创建线程的源窗口发送消息
* onmessage，获取接收消息的事件句柄
* importScripts(urls)，导入其他javaScript脚本文件，导入的脚本文件必须与使用该线程文件的页面在同一个域中，并在同一个端口中
* navigator对象，与window.navigator对象类似，具有appName、platform、userAgent、appVersion这些属性
* sessionStorage/localStorage，可以在线程中使用Web Storage
* XMLHttpRequest，可以在线程中处理Ajax请求
* Web Workers，可以在线程中嵌套线程
* setTimeout()/setInterval，可以在线程中实现定时处理
* close，可以结束本线程
* eval()、isNaN()、escape()等，可以使用所有JavaScript核心函数
* object，可以创建和使用本地对象
* WebSockets，可以使用WebSockets API来向服务器发送和接收消息

## 获取地理位置信息

如果浏览器支持，且设备具有定位功能，就能够直接使用这组API来获取当前位置信息

### Geolocation API的基本知识

#### 取得当前地理位置

可以使用geolocatiion的getCurrentPositon方法来获取用户当前的地理位置信息；当在浏览器中打开使用了Geolocation API来获得用户当前位置信息的页面时，浏览器会询问用户是否共享位置信息

错误回调函数使用一个error对象作为参数，该对象具有以下两个属性：
* code属性，用户拒绝了位置服务(1)；获取不到位置信息(2)；获取信息超时错误(3)
* message属性，该属性为一个字符串，在该字符串中包含了错误信息，这个错误信息在开发和调试时将很有用。有些浏览器中不支持message属性，譬如Firefox3.6以上

getCurrentPostion方法中的第三个参数可以省略，它是一些可选属性的列表
* enableHighAccuracy，是否要求高精度的地理位置信息，这个参数在很多设备上设置了都没有用，因为使用在设备上时需要结合设备电量、具体地理情况来综合考虑。因此，多数情况下把该属性设为默认，由设备自身来调整
* timeout，对地理位置信息的获取操作做一个超时限制（单位为毫秒）。如果在改时间内为获取到地理位置信息，则返回错误
* maximumAge，对地理位置信息进行缓存的有效时间（单位为毫秒）；如果该值被指定为0，则无条件重新获取新的地理位置信息

#### 持续监视当前地理位置的信息

使用watchPostion方法来持续获取用户的当前地理位置信息，它会定期地自动获取

watchCurrentPosition方法返回一个数字，这个数字的使用方法与JavaScript脚本中setInterval方法的返回参数的使用方法类似，可以被clearWatch方法使用，停止对当前地理位置信息的监视

#### 停止获取当前用户的地理位置信息

可以使用clearWatch停止对当前用户的地理位置信息的监视，该方法的参数为调用watchCurrentPosition方法监视地理位置信息时的返回参数

### position对象

position对象具有如下这些属性：
* latitude，当前地理位置的纬度
* longitude，当前地理位置的经度
* altitude，当前地理位置的海拔高度（不能获取时为null）
* accuracy，获取到的纬度或经度的精度（以米为单位）
* altitudeAccuracy，获取到的海拔高度的精度（以米为单位）
* heading，设备的前进方向。用面朝正北方向的顺时针角度来表示（不能获取时为null）
* speed，设备的前进速度（以米/秒为单位，不能获取时为null）
* timestamp，获取地理位置信息时的时间

### 在页面上使用google地图

在页面中使用google地图，需要使用到Google Map API
1. 在页面中导入Google Map API的脚本文件
2. 设定地图参数，设定放大倍数、中心点和地图类型
3. 创建地图，并在页面中显示
4. 在地图上创建标记
5. 设置标注窗口并制定标注窗口中注释文字
6. 打开标注窗口