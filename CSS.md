# <center>CSS</center>
## 概念
* 层叠：CSS中的冲突规则
* 读者样式表：网上冲浪的人（或读者）可以利用某些浏览器创建自己的样式表（可以是指令、规则、甚至样式）
* CSS是一种样式语言
### 基本术语
**元素**
  元素是文档结构的基础，文档中的每个元素都对文档的表现起一定作用。
  在CSS2.1中，意味着每个元素生成一个框（box，也称为盒），其中包含元素内容
**替换元素和非替换元素**
1. 替换元素实质用来替换元素内容的部分并非由文档内容直接表示（img元素、input元素）。替换元素显示时也生成框
2. 非替换元素的内容由用户代理（通常是一个浏览器）在元素本身生成的框中显示（段落、标题、表单元格、列表和XHTML中几乎所有元素）
**块级元素和行内元素**
1. 块级元素生成一个元素框，（默认地）它会填充父元素的内容区，旁边不能有其他元素（p和div）。替换元素可以是块级元素，不过通常不是。列表项是块级元素的一个特例，除了表现方式与其他块元素一致，列表项还会生成一个标记符，这个标记符会“关联”到元素框
2. 行内元素在一个文本行内生成元素框，而不会打断这行文本（XHTML中的a元素、strong和em）
注：在HTML和XHTML中，块级元素不能继承自行内元素（即不能嵌套在行内元素中）。但是在CSS中，对于显示角色如何嵌套不存在任何限制（display）
### 结合CSS和XHTML
1. link标记
    * link标记在HTML规范中已经存在多年
    * 基本目的是允许HTML创作人员将包含link标记的文档与其他文档相关联
    * 这些样式表并不是HTML文档的一部分，但仍会由HTML文档使用，称为外部样式表
    * 为了成功加载一个外部样式表，link必须放在head元素中，不能放在其他元素内部
    * 外部样式表是一个规则列表（不能包含XHTML或其他任何标记语言）
    * 候选样式表：只有用户选择这个样式表时才会用于文档表现（如果浏览器能使用候选样式表，它会使用link元素的title属性值生成一个候选样式列表）
    * rel属性为stylesheet的样式表优先于候选样式表，而且第一次显示文档时会使用这个首选样式表。不过，一旦选择了候选样式表，就不会再使用首选样式表了（rel为stylesheet，tilte属性存在）
    * 如果将一组样式表指定为首选样式表，那么只会使用其中某一个（具体是哪一个无法确定）
    * 如果没有为样式表指定title，那么它将作为一个永久样式表，始终用于文档显示
2. style元素
    * style一定要使用type属性
    * 开始和结束style标记之间的样式称为文档样式表，或嵌套样式表
    * 可以使用@import指令包含多个外部样式表链接（指示Web浏览器加载一个外部样式表，并在表现HTML文档时使用其样式）
    * @import出现在style容器中，放在其他CSS规则之前，否则不起作用
    * 每个@import指令的样式表都会加载并使用，无法指定候选样式表
    * @import指令可以限制导入的样式表应用与一种或多种媒体
注：向后可访问性--如何让较老的浏览器也能访问文档（浏览器会忽略其无法识别的标记；标记中的声明不一定会被忽略）。建议将声明包含在一个注释标记中
3. 内联样式
    * 如果只想为单个元素指定一些样式，而不需要嵌套或外部样式表，就可以使用HTML的style属性来设置内联样式
    * 除了body外部出现的标记（如，head或title），style属性可以与任何其他HTML标记关联
    * 不推荐使用style属性（内联样式会削弱集中式样式的有点）
## 选择器
CSS的主要优点之一：能很容易地向所有同类型的元素应用一组样式（更容易完成一些全局性修改）
### 基本规则
#### 规则结构
* 选择器：选择器定义了将影响文档中的哪些部分
* 声明块：声明块由一个或多个声明组成，每个声明则是一个属性值对（CSS属性和改属性值）
每个样式表由一系列规则组成
##### 元素选择器
最常见的选择器往往是HTML元素，但也不完全是这样（如果CSS文件包含XML文档样式）。在XML中，什么都可以作为选择器，因为XML允许创建新的标记语言
##### 声明和关键字
几乎在所有情况下，值要么是一个关键字，要么是该属性可取关键字的一个列表（包括一个或多个关键字）
如果声明使用了不正确的属性，或者不正确的值，整个声明都会被忽略
CSS关键字使用空格分隔（CSSfont属性，可以使用/分隔字体大小和行高）
### 分组
#### 选择器分组
可以将任意多个选择器分组在一起，用逗号分隔
#### 通配选择器
通配选择器：CSS2引入，可以与任何元素匹配
#### 声明分组
最后一个声明后加分号
#### 结合选择器和声明的分组
### 类选择器和ID选择器
类选择器和ID选择器允许以独立于文档元素的方式来指定样式
只有适当地标记文档后才能使用这些选择器
#### 类选择器
应用样式而不考虑具体涉及的元素，最常用的方法就是使用类选择器
类选择器可以结合元素选择器
可以组合使用一个通用类选择器和一个元素特定类选择器
如果只想选择所有类名相同的元素，可以在类选择器中忽略同年配选择器
#### 多类选择器
HTML中，一个class值中有可能包括一个此列表，各个词之间用空格分隔
通过把两个类选择器链接在一起，仅可以选择同时包含这些写类名的元素（类名顺序不限）
如果多类选择器包含的类名列表中所没有的一个类名，就会匹配失败
#### ID选择器
ID选择器前有一个#号也称棋盘号
ID选择器可以忽略通配符选择器
在一个HTML文档中，ID选择器会使用一次，而且仅一次
ID选择器不能结合使用
注：点号加类名的记法对XML文档不一定能奏效，#号加ID的记法可以在任何文档语言中使用
注：类选择器和ID选择器可能是区分大小写的，这取决于文档语言。HTML和XHTML将类和ID值定义为区分大小写
### 属性选择器
对于类选择器和ID选择器，实际上只是选择属性（HTML、SVG和MathML文档特定）
在其他标记语言中，不能使用这些类和ID选择器，于是CSS2引入了属性选择器，它可以根据元素属性及属性值来选择元素
#### 简单属性选择
选择class属性，属性值不限--h1[class]
可以根据多个属性进行选择，只需将属性选择器链接在一起
#### 根据具体属性值选择
除了选择某些属性的元素，还可以进一步缩小选择范围，只选择特定属性值的元素
这种格式要求必须与属性值完全匹配
注：ID选择器与指定id属性的属性选择器不是一回事，存在微妙但是重要的差别
#### 根据部分属性值选择
如果属性能接受词列表（词间用空格分隔），可以根据其中任意一个词进行选择
例：p[class~="warning"]
还有一个更高级的CSS选择器模块，在CSS2完成后发布的，其中包含更多的部分值选择器（或者按规范说，称为“子串匹配属性选择器”）
* [foo^="bar"] 选择foo属性值以"bar"开头的所有元素
* [foo$="bar"] 选择foo属性值以"bar"结尾的所有元素
* [foo*="bar"] 选择foo属性值包含子串"bar"的所有元素
#### 特定属性选择器
例：[lang|="en"] 这个规则会选择lang属性等位en或者以en-开头的所有元素
用途：匹配语言值
### 使用文档结构
使用文档结构是CSS确定和应用样式的唯一途径
在确定以何种方式向文档应用样式时，结构还承担着更重要的角色
#### 理解父子关系
父子关系是祖先-后代关系的特例
body元素时浏览器默认显示的所有元素的祖先，html元素则是整个文档的祖先，出于这个原因，html元素也被称为根元素
#### 后代选择器
后代选择器也称为包含选择器或上下文选择器
定义后代选择器就是来创建一些规则，它们仅在某些结构中起作用，而在另外一些结构中不起作用
后代选择器中两个元素间的层次间隔可以是无限的
#### 选择子元素
在某些情况，可能并不想选择任意一个后代元素；而是希望缩小范围，只选择另一个元素的子元素（使用子结合符>）
子选择器限制为只匹配树中直接相连的元素
#### 选择相邻兄弟元素
要选择紧接在另一个元素后的元素，而且两者有相同的父元素，可以使用相邻兄弟结合符+
用一个结合符只能选择两个相邻兄弟中的第二个元素
两个元素间的文本内容不会影响相邻兄弟结合符起作用

### 伪类和伪元素
利用伪类选择器和伪类元素选择器可以为文档中不一定具体存在的结构指定样式，或者为某些元素（甚至是文档本身）的状态所指示的幻像类指定样式；会根据另外某种条件而非文档结构向文档中某些部分应用样式，而且无法通过研究文档的标记准确地推断出采用何种方式应用样式
#### 伪类选择器
HTML标记a
有两种基本的锚类型：已访问的和未访问的（将文档中的链接与用户的浏览历史相比较），这些类型称为伪类，使用这些伪类的选择器称为伪类选择器
例：a:visited 所有伪类和伪元素关键字前面都有一个冒号，这个冒号是伪类或伪类元素的名片
#### 链接伪类
CSS2.1定义了两个只应用于超链接的伪类
* :link 指示作为超链接（即有一个href属性）并指向一个未访问地址的所有锚（有些浏览器可能会不正确地将：link解释为指向任何超链接，包括已访问和未访问的超链接）
* :visited 指示作为已访问地址超链接的所有锚
注：它们是静态的--第一次显示后，它们一般不会再改变文档的样式
#### 动态伪类
CSS2.1定义了3个动态伪类，它们可以根据用户行为改变文档外观
* :focus 指示当前拥有输入焦点的元素，也就是说，可以接受键盘输入或者能以某种方式激活的元素
* :hover 指示鼠标指针停留在哪个元素上
* :active 指示被用户输入激活的元素，例如，鼠标指针停留在一个超链接上时，如果用户点击鼠标，机会激活这个超链接
伪类推荐顺序：link-visited-focus-hover-active
#### 动态样式的实际问题
a:link, a:visited {font-size: 13px;}
a:hover {font-size: 20px}
使用动态伪类改变布局，支持这种行为的用户代理在锚处于悬停状态时必须重绘文档，这就要求重新显示该链接之后的所有内容
CSS规范指出，文档第一次显示之后，用户代理不必重绘文档，所以不能完全依赖预想的效果
#### 选择第一个子元素
使用静态伪类:first-child来选择元素的第一个子元素（选择作为某元素第一个子元素的所有元素）
#### 根据语言选择
使用:lang()伪类来完成语言选择
:lang()伪类类似于|=属性选择器
区别：伪类选择器语言信息可以从很多来源得到，而且其中一些可能在元素之外
CSS2.1指出：在HTML中，语言由lang属性和META元素的组合来确定，还包括协议提供的信息（如HTTP首部）
注：伪类比属性选择器稍微健壮一些，在需要语言特定的样式时，大多数情况下伪类都是更好的选择
#### 结合伪类
在CSS2.1中，可以在同一个选择器中结合使用伪类（顺序指定不重要）
注：不要把互斥伪类结合使用（用户代理会忽略这种选择器，相应地忽略整个规则--这一点不能保证）
### 伪元素选择器
就像伪类为锚指定幻想类一样，伪元素能够在文档中假想的元素，从而得到某种效果
CSS2.1中定义了4个伪元素：设置首字母样式、设置第一行样式、设置之前和之后元素的样式
#### 设置首字母样式
会导致用户代理对一个假象的元素作出响应（假象元素由用户代理动态构造）
#### 设置第一行的样式
:first-line可以用来影响元素中的第一个文本行
注：在CSS2中，:first-letter和:first-line伪元素只能应用于标记或段落之类的块级元素，而不能应用于超链接等行内元素；在CSS2.1中:first-letter能应用到所有元素；不过能应用:first-line和:first-letter的CSS属性还是有一些限制
* :first-letter--所有font属性;color;所有background属性;所有margin属性;所有padding属性;所有border属性;text-decoration;vertical-align（如果float设置为none）;text-transform;line-height;float;letter-spacing（CSS2.1）;word-spacing（CSS2.1）;clear（仅使用与CSS2；CSS2.1已去除）;text-shadow（仅适用于CSS2）
* :first-line--所有font属性;color;所有background属性;word-spacing;letter-spacing;text-decoration;vertical-align；text-transform;line-height;clear（仅使用与CSS2；CSS2.1已去除）;text-shadow（仅适用于CSS2）
注：所有伪元素都必须放在常出现在该伪元素的选择器的最后面
#### 设置之前和之后元素的样式
CSS2.1允许插入生成的内容，然后使用伪元素:before和:after直接设置样式
伪元素用于插入生成的内容，并设置其样式

## 结构和层叠
继承：继承是从一个元素向其后代元素传递属性值所采用的机制
确定向一个元素应用哪些值时，用户代理不仅要考虑继承，还要考虑声明的特殊性，另外需要考虑声明本身的来源。这个过程称为层叠
### 特殊性
一个元素可以使用两个或多个规则来选择，每个规则都有其自己的选择器，通过每个选择器的特殊性，确定哪个规则更强
对于每个规则，用户代理会计算选择器的特殊性，并将这个特殊性附加到规则中的各个声明
如果一个元素有两个或多个冲突的属性声明，那么有最高特殊性的声明胜出
所有样式冲突的解决都由层叠来处理
选择器的特殊性由选择器本身的组件确定。特殊性值表述为4个部分
* 对于选择器中给定的各个ID属性值，加0,1,0,0
* 对于选择器中给定的各个类属性值、属性选择或伪类，加0,0,1,0
* 对于选择器中给定的各个元素和伪元素，加0,0,0,1。（CSS2.1指出，伪元素有特殊性，而且特殊性为0,0,0,1）
* 结合符合通配选择器对特殊性没有任何贡献
注：特殊性的值从左向右排序
#### 声明和特殊性
一旦确定一个选择器的特殊性，这个值将授予其所有相关声明
在计算声明特殊性的过程中，用户代理会解组计算特殊性
任何情况下，用户代理都会确定哪些规则与一个元素匹配，计算出所有相关声明及其特殊性，确定哪些规则胜出，然后将胜出的规则应用到元素，从而得到应用样式后的结果（这个行为是层叠的一部分）
#### 通配选择器特殊性
通配选择器对一个选择器的特殊性没有贡献，其特殊性为0,0,0,0，这与根本没有特殊性有区别
结合符没有特殊性，甚至连0特殊性都没有。因此，它们对选择器的总特殊性没有任何影响
#### ID和属性选择器的特殊性
ID选择器和指定id属性的属性选择器在特殊性上有所不同
#### 内联样式特殊性
一般地，第一个0是为内联样式声明保留的，它比所有其他声明的特殊性都高。（CSS2.1新增）每个内联声明的特殊性都是1,0,0,0
注：CSS2特殊性包含3个值，而不是4个。在CSS2中内联样式特殊性与ID选择器特殊性相同，所以ID选择器很容易覆盖内联样式
#### 重要性
有时候某个声明可能非常重要，超过了其他所有声明。CSS2.1称之为重要声明
重要声明在声明的结束分号之前插入!important来标志（如果!important位置放置错误，整个声明都会无效）
所有!important声明会分组在一起，重要声明的特殊性冲突会在重要声明内部解决，而不会与非重要声明相混；所有非重要声明也归为一组，使用特殊性解决冲突
如果一个重要声明和一个非重要声明冲突，胜出的总是重要声明

### 继承
基于继承机制，样式不仅应用到指定的元素，还会应用到它的后代元素
将声明color:gray;应用到ul元素时，这个元素会采用该声明。这个值再沿着树向下传播到后代元素，并一直继续，直到再没有更多的后代元素继承这个值为止。值不会向上传播；也就是说元素不会把值向上传递到其祖先
注：在HTML中，对于向上传播规则有一个例外；应用到body元素的背景样式可以传递到html元素，相应地可以定义其画布
注：有些属性不能继承（如属性border）；一般地，大多数框模型属性（包括外边距、内边距、背景和边框）都不能继承
注：继承的值没有特殊性（0特殊性比无特殊性强）
注：不加区别地使用通配继承器可能存在短路继承的效果（覆盖继承的属性）
#### 继承bug
由于不同的浏览器实现中可能存在的问题，创作人员不能指望依靠继承在所有情况下得到预想的结果
### 层叠
问题：如果特殊性相等的两个规则同时应用到同一个元素
CSS所基于的方法就是让样式层叠在一起，这是通过结合继承和特殊性做到的
CSS2.1的层叠规则
1. 找出所有相关规则，这些规则都包含与一个给定元素匹配的选择器
2. 按显示权重对应用到该元素的所有声明排序。标志!important的规则的权重要高于没有!important标志的规则。按来源对应用到给定元素的所有声明排序。共有3种来源：创作人员、读者和用户代理。正常情况下，创作人员的样式要胜过读者样式；有!important标志的读者样式要强于所有其他样式，这包括有!importan标志的创作人员样式。创作人员样式和读者演示逗比用户代理的默认样式要强
3. 按特殊性对应用到给定元素的所有声明排序。有较高特殊性的元素权重要大于有较低特殊性的元素
4. 按出现顺序对应用到给定元素的所有声明排序。一个声明在样式表或文档中越后出现，它的权重越大。如果样式表中有导入样式表，一般认为出现在导入样式表的声明在前，主样式表中的所有声明在后
#### 按权重和来源排序
读者重要声明>作者重要声明>作者正常声明>读者正常声明>浏览器默认样式（用户代理声明；通常受用户首选项影响）
#### 按特殊性排序
如果向一个元素应用多个彼此冲突的声明，而且它们的权重相同，则按特殊性排序徐，最特殊的声明最优先
#### 按顺序排序
如果两个规则的权重、来源和特殊性完全相同，那么在样式表中最后常出现的一个会胜出
style属性>文档样式表>外部样式表
注：链接样式顺序--LVHA（权重、来源、特殊性一致）CSS2规范推荐顺序
注：出现冲突时顺序才重要
注：:link和:visited样式的顺序不重要
注：通过伪类链接在一起，能缓解特殊性和顺序带来的问题
### 非CSS表现提示
文档可能包含非CSS的表现提示，例如font元素。非CSS提示别处理为特殊性为0，并出现在创作人员样式表最前面。只要有创作人员或读者样式，这种表现提示就会被覆盖，但是用户代理的样式不能将其覆盖

## 值和单位
在利用CSS能做的几乎所有工作中，其基础都是单位，这是影响所有属性的颜色、距离和大小的一种元素
### 数字
CSS中有两类数字：整数（“完整”的数）和实数（小数）
整数和实数都可以是正数或负数，不过属性可能（通常会）限制所允许的数字范围
### 百分数
百分数值是一个计算得出的实数，其后跟有一个百分号。
百分数值几乎总是相对于另外一个值，这个值可以是任意的：可能是同一元素另一个属性的值，也可以是从父元素继承的一个值，或者是祖先元素的一个值
接受百分数值的属性会对所允许的百分数值定义某些限制，还会定义百分数计算到什么程度
### 颜色
设置颜色的选择（HTML）
* 按名使用
* 使用十六进制代码
在CSS中这两种描述颜色的方法都仍然保留，另外还提供了一些其他的描述方法
#### 命名颜色
在CSS2.1中，CSS规范定义了17个颜色名。这包括HTML4.0.1中定义的16个颜色，并外加一个橙色
aqua fuchsia lime olive red white black gray marron orange silver yellow blue green navy purple teal
注：大多数Web浏览器能识别多大140个颜色敏感，包括上述17个标准颜色
注：CSS3中包含的140种颜色的扩展颜色表基于标准X11 RGB值
注：CSS中还有一些更详细、更精确的方法用于指定颜色。其好处在于，采用这些方法可以指定色谱中的任何颜色
#### 使用RGB指定颜色
计算机通过组合不同的红色、绿色和蓝色分量来创造颜色
##### 函数式RGB颜色
有两种颜色值类型使用函数式RGB记法而不是十六进制记法
rgb(color)，其中color用一个百分数或整数三元组表示，百分数值在0%~100%，整数范围在0~255
注：black-rgb(0%,0%,0%) white-rgb(100%,100%,100%) red-rgb(100%,0%,0%) maroon-rgb(50%,0%,0%)
注：百分数记法中也可以使用分数（有些用户代理会忽略小数点，取最接近的整数）
##### 十六进制RGB颜色
十六进制记法在数学上等价于整数三元记法
#RRGGBB
如果组成十六进制数的3组数各自成对，CSS还允许采用一种简写记法，这种记法的一般语法是#RGB（浏览器取每一位，并将其复制成两位）
#### Web安全颜色
“Web安全"颜色是指，在256色计算机系统上总能避免抖动的颜色
Web安全颜色可以表示为RGB值20%和51（相应的十六进制为33）的倍数。另外0%或0也是一个安全值
RGB三个分量都需要是0%或20%的倍数
### 长度单位
很多CSS属性（如外边距）都依赖于长度度量来适当地显示各种页面元素
注：当长度为0时，后面不需要跟单位
#### 绝对长度单位
在Web设计中几乎很少使用绝对长度单位。只有当浏览器知道用来显示页面的显示器、所用的打印机或其他任何用户代理的所有细节时，以下单位才真正有用
* 英寸（in）--1英寸是2.54cm
* 厘米（cm）--1厘米等于0.394英寸
* 毫米（mm）--1厘米等于10毫米
* 点（pt）--点是一个标准印刷度量单位；一英寸是72点（点是米制体系广泛使用之前定义的）
* 派卡（pc）--派卡也是一个印刷术语；一派卡相当于12点
注：在一个Web浏览器上，显示会受显示器的尺寸影响，另外所设置的显示器分辨率也会有影响
##### 处理绝对长度
分辨率设置为1024 768像素，屏幕大小为14.22英寸宽、10.67英寸高，且显示区完全覆盖整个屏幕，那么每个像素的宽和高都为1英寸的1/72。实际上每英寸的实际像素数（ppi）都高于72
注：绝对单位在定义打印文档的样式表时更为有用

#### 相对长度单位
相对长度单位会根据其他事物的关系来度量。所度量的实际（或绝对）距离可能因为不在其控制之下的其他因素而改变（如屏幕分辨率、可视区的宽度、用户的首选项设置，以及很多其他方面）。另外，对于某些相对单位，其大小几乎总是对应于使用该单位的元素，因此会因元素的不同而不同
三种相对长度单位：em、ex和px
前两个单位代表em-height和x-height，这是常用的印刷单位；px取决于设备分辨率
##### em和ex单位
在CSS中，1个em定义为一种给定字体的font-size值（这个值可能随元素的不同而不同；在设置字体大小时，em的值会相对于父元素的字体大小改变）
ex是指所用字体中小写x的高度
##### em和ex的实际问题
实际中，很多用户代理的做法是：取em的值，再取其一半作为ex值（计算ex高度值相当困难--大多数字体没有内置ex高度值）
注：一些浏览器（包括面向Mac的Internet Exploer5）会在内部显示一个小写的x，并计算响应的像素值来确定其高度与此字符font-size值之比，从而试图确定给定字体的x高度
注：取em的一半作为ex的简便做法会逐渐淡出历史
##### 像素长度
显示器被划分成一个由小框组成的网格。每个框就是一个像素
注：如果按像素设置字体大小，Windows平台IE7之前的用户将无法使用其浏览器中的“文本大小”菜单调整文本的大小（使用em用户才能调整文本大小）
注：非常适合用像素来度量图像大小，除了希望图像能随文本的大小缩放时
注：基于向量的图像；基于像素的图像
##### 像素理论
CSS规范建议如果一个显示类型的设置与96ppi截然不同，用户代理应当把像素度量缩放为一种“参考像素”
Web浏览器几乎总会在显示器上使用实际像素；如果采用其他显示设备（如打印机），用户代理必须将像素重新缩放为更合理的度量（打印代码必须确定一个像素有多少个点，为此，它可能要使用96ppi参考像素）
由于很可能会进行重新缩放，像素被定义为一种相对度量单位，尽管在Web设计中像素表现得很像是绝对单位
注：em最灵活，因为它随字体大小缩放，所以元素和元素操作都能更为一致；对于元素的其他方面，可能更适合使用像素，如元素的边框或定位
### URL
一般格式 url(protocol://server/pathname)
一般格式 url(pathname)
* 绝对URL，不论它放在哪里（或者放在哪个页面上），它都能正常工作，因为它定义了Web空间中的一个绝对位置
* 相对URL，它指定的是一个相对于该URL所在文档的位置
注：在CSS中，相对URL要相对于样式表本身，而不是相对于使用该样式表的HTML文档（Netscape Navigator4会相对于HTML文档；使用绝对URL）
注：url和开始括号间不能有空格
### 关键字
如果一个值需要用某个词来描述，这种词就称为关键字
关键字none，它不同于0--可以去除一个HTML文档中链接的下划线，反之underline
注：如果一个属性接受关键字，那么其关键字将只针对该属性的作用域定义（不同属性，同一关键字行为可能不同）
##### inherit
CSS2.1中inherit关键字是所有属性共有的
作用：使一个属性的值与其父元素的值相同
注：在大多数情况下，不必指定继承，因为大多数属性本身会自然地继承
### CSS2单位
CSS2中的另外几个单位都与声音样式表有关（支持语音的浏览器会使用这种样式表）
* 角度值--用于定义给定的声音从哪个位置发出。度deg 梯度grad 弧度rad
* 时间值--用于指定语音元素间的延迟。毫秒ms 秒s
* 频率值--用于为语音浏览器可以产生的声音声明一个给定频率。 赫兹Hz 兆赫Mhz（不区分大小写）
注：CSS2和CSS2.1规范都要求URI要以url()形式声明
## 字体
目前还没有一种办法能确保在Web上一致地使用字体，因为没有一种统一描述字体和字体的变形的方法
注：字体需要用户机器安装
CSS2支持可下载字体，并定义了相应属性
注：出于性能方面的原因，阅读器总会拒绝下载字体
CSS字体处理中最复杂的部分是字体系列匹配和字体加粗匹配，其次是字体大小计算。CSS中与字体有关的方面还包括字体风格（如斜体）和字体变形（如小型大写字母）
### 字体系列
CSS力图帮助用户代理把这种混乱状况（相同的字体可能有很多不同的称呼）理清楚
例：Times实际上是多种变形的一个组合，即Times实际上是一个字体系列，而不只是单个的字体
特定字体系列：Times、Verdana、Helvetica或Arial
通用字体系列
* serif字体--这些字体成比例，而且有上下短线（Times、Georgia、和New Century Schoolbook）
* Sans-serif字体--这些字体是成比例的，而且没有上下短线（Helvetica、Geneva、Verdna、Arial和Univers）
* Monospace字体--字体不成比例（每个字符宽度完全相同；这些字体可能有上下短线，也可能没有；Courier、Courier New和Andale Mono）
* cursive字体--这些字体视图模仿人的手写体（Zapf Chancery、Author和Comic Sans）
* Fantasy字体--这些字体无法用任何特征来定义，无法很容易地将其划归到任何一种其他的字体系列当中（Western、Woodblock和Klingon）
注：理论上讲，用户安装的任何字体系列都会落入到上述某种通用系列当中（例外情况很少）
#### 使用通用字体系列
如果使用一种通用字体系列，用户代理会从该系列字体选择一个字体
#### 指定字体系列
如果字体不可用，用户代理就根本不可能使用这个规则。它不会忽略这个规则，可能使用用户代理默认字体来显示
注：可以结合特定字体名和通用字体系列，创建于预想完全相同（或者至少很接近）的文档
注：如果一个字体名中有一个或多个空格，或者如果字体名包括#或$之类的符号，需要在font-family声明中加引号，这样用户代理才能搞清楚字体名到底是什么
注：根据CSS2.1规范，包含符号的字体名并不一定要加引号，但这是一种推荐做法；如果字体名中只包含一个词，而且这个词与font-family的任何关键字都不冲突，就不需要加引号
### 字体加粗
利用font-weight属性，CSS允许对字体加粗有更多控制
关键字100~900，定义这些关键字是为了映射字体设计中的一个很常见的特性，即为字体指定9级加粗度
如果一个字体内置了加粗级别，那么这些数字就直接映射到预定义的级别，100对应最细的字体变形，900对应最粗的字体变形
这些数字本身并没有固定的加粗度，CSS规范只是指出，每个数对应一个加粗度，它至少与前一个数指定的加粗度相同
400--normal 700--bold 
如果给定的字体系列这种定义的加粗度少于9中，用户代理必须以一种预定的方式填补这些“空白”
* 如果未指定500加粗度，其字体加粗与400相应加粗相同
* 如果未指定300的加粗度，则为之指定下一个比400更细的变形（如果没有可用的较细变形，为300指定的变形等同于400的相应变形）
* 如果未指定600的加粗度，会指定下一个比400更粗的变形（如果没有可用较粗变形，为600指定的变形则等同于500的相应变形）
#### 让字体更粗
如果将一个元素的加粗设置为bolder，用户代理首先必须确定从父元素继承的font-weight值。然后选择一个数，它对应于比所继承值更粗的一个字体加粗，而且在满足这个条件的所有数中选择最小的一个数。如果没有可用的字体，用户代理会把该元素的字体加粗设置为下一个更大的数字值
注：normal->bold  bold-800 数值首先转化为normal或bold再进行加粗l
#### 让字体更细
lighter的做法完全一样，不过它会导致用户代理将加粗度下移而不是上移

### 字体大小
font-size属性与看到的实际字体大小间的具体关系由字体的设计者来确定
字体本身的em框。这个em方框（以及相应的字体大小）不一定只是字体中字符建立的任何边界。相反，它指示如果没有额外行间距（CSS中的Line-height）设置字体时基线见得距离。某种字体的字符可能比默认的基线间距要高。出于这种原因，定义字体时可能要求所有字符都小于其em方框
font-size的作用是为给定字体的em框提供一个大小，而不能保证实际显示的字符就是这种大小
#### 绝对大小
根据CSS1规范，一个绝对大小与洗衣歌绝对大小之间的差别（或缩放因子），应当是向上1.5，或向下0.66.缩放因子不一定非得是1.5，不仅因为不同用户代理缩放因子可能不同，此外还有一个原因：CSS2中缩放因子可能介于1.0~1.2之间
注：不同用户代理可能将“默认”字体指定为不同的绝对关键字
#### 相对大小
larger和smaller：这两个关键字使元素大小相对于其父元素大小在绝对大小梯度上上移或下移，在此会使用计算绝对大小时采用的缩放因子
注：不同于加粗的相对值，相对大小值不必限制在绝对大小范围内
#### 百分数和大小
百分数数值总是根据从父元素继承的大小来计算
注：Web浏览器很可能将实数值取整为与之最接近的整数像素
注：高级用户代理在打印文档时会近似小数像素，或者可能通过反混淆来近似小数像素
有时，CSS定义长度值em等价于百分数值，即确定字体大小事1em等于100%。使用em度量时，会应用百分数的相同规则
#### 字体大小和继承
尽管在CSS中font-size是可以继承的，不过继承的是计算值而不是百分数
如果用户代理每一步都取整，当与更多的百分数相乘，取整错误就会开始积累
嵌套列表或者嵌套表可能导致缩放失控--难以阅读
#### 使用长度单位
可以使用长度值来设置font-size
假设用户代理知道现实媒体中没英寸使用多少点。不同的用户代理会做不同的假设，有些基于操作系统，有些基于首选项设置，还有些会基于编写用户代理的程序员的假设
注：尽管结果与现实可能不能完全匹配，但是度量彼此间一致
注：由于不同操作系统间的差别，许多创作人员选择用像素指定字体大小。Web页面上既有文本又有图像，就很适合采用这种方法
注：使用像素来设置文本大小与使用其他方法一样，无法保证总有同样的大小。其他方法（关键字和百分数）都更为健壮（也更为用户友好），因为可以用这些方法在用户默认字体大小的基础上缩放文本

### 风格和变形
font-style font-variant
#### 有风格的字体
normal “竖直”的文本；“非斜体或倾斜的文本”
italic和oblique的区别
* 斜体（italic）是一种单独的字体风格，对每个字母的结构有一些小改动，来反映变化的外观（对于serif字体尤其如此）
* 倾斜（oblique）文本则是正常竖直文本的倾斜版本
注：Italic、Cursive和Kursiv的字体总是映射到italic关键字，而oblique总是对应到标为Oblique、Slanted和Incline的字体
注：如果没有Italic字体，但是有一种Oblique字体，则要在需要前者的地方使用后者。如果情况反过来，存在Italic字体，但是没有Oblique字体，根据规范用户代理可能不会把后者换成前者。最后，用户代理可能只是计算竖直字体的一个倾斜版本来生成oblique字体
注：许多操作系统中声明为italic的给定字体可能会从italic切换到oblique，这取决于字体的具体大小
排版约定：块引用应当是斜体，而引用中特别强调的文本应当是竖直的
#### 字体变形
font-variant，有两个非继承值：默认值normal和small-caps（小型大写字母--这种字体采用不同大小的大写字母）
注：之所以使用一个字体属性来声明small-caps，原因是有些字体有特定的small-caps字体，这要通过一个字体属性来选择。如果不存在这样的字体，规范中提供了两种选择。第一种是让用户代理自己缩放大写字母来创建一个small-caps字体；第二种方法是让所有字母都的大写，而且大小相同
### 拉伸和调整字体
CSS2中有两个字体属性在CSS2.1中未出现（还没有任何一个浏览器实现这两个属性）
前一个属性允许将字体水平拉伸，第二属性允许在创作人员的首选字体不可用时，对替换字体进行智能缩放
注：影响字体是否能辨识的因素包括其大小和其x-height。x-height除以font-size的结果称为方面值。如果字体的方面值较高，随着字体大小的减少这种字体往往还能辨识；反过来，如果字体的方面值较低，就会更快地变得不可辨识
### font属性
font属性是涵盖所有其他字体属性（以及少数其他内容）的一个简写属性
一般来讲，font声明可以有上述各个字体属性的任何值，或者有一个“系统字体”值
font-style font-weight font-variant顺序任意
font-size font-family顺序固定而且font声明中必须有这两个值。如果少了其中某个属性，那么整个规则无效，很可能被用户代理完全忽略

#### 增加行高
可以使用font设置line-height，尽管line-height是一个文本属性而不是字体属性。这可以作为对font-size的一个补充，并用一个斜线（/）与之分隔
#### 适当地使用简写
使用简写属性font时，所有被忽略的值都会重置为其默认值
#### 使用系统字体
如果希望Web页面结合用户操作系统的设置，在这种情况下，font的系统字体值会很方便。这些值用于取得此操作系统中元素的字体大小、字体系列、字体加粗、字体风格和字体变形，并将其应用到一个元素
* caption--用于有标题控件，如按钮 
* icon--用于对图标加标签
* menu--用于菜单，即下拉菜单和菜单列表
* message-box--用于对话框
* samll-caption--用于对小控件加标签
* status-bar--用于窗口状态条
注：系统字体可能只能整体设置；不过可以修改其中单个值
注：如果需要一种系统字体，但是用户机器上不存在这样一种字体，用户代理可能会试图找出一种近似的字体（如缩小caption字体的大小，从而得到small-caption字体），如果无法找到这样的近似字体，用户代理就要使用它自己的一种默认字体。如果可以找到一个系统字体，但是无法读取其所有值，就应当使用默认值
### 字体匹配
CSS允许匹配字体系列、加粗和变形。所有这些都是通过字体匹配完成的，这是一个相当复杂的过程
1. 用户代理创建（或访问）一个字体属性数据库（这个数据库列出了用户代理能访问的所有字体的各种CSS属性；一般地，这将是机器上安装的所有字体，虽然可能还包含另外一些字体--用户代理内置字体；如果用户代理遇到两种相等的字体，会把其中一个忽略）
2. 用户代理取得应用了字体属性的元素，并构建一个字体属性列表，其中列出显示该元素的必要字体属性。基于这个列表，用户代理先对显示元素时使用的字体系列做第一个选择。如果完全匹配，那么用户代理就可以使用这个字体。否则，需要多做一些工作
    1. 字体首先根据font-style进行匹配。关键字italic可以与所有标有“italic”或“oblique”的字体匹配。如果没有这样的字体，则匹配失败
    2. 接下来再根据font-variant进行匹配。与small-caps匹配的字体可以使表位small-caps的字体，也可以是允许合成small-caps风格的字体，或者使用大写字母替换小写字母的字体
    3. 然后根据font-weight匹配，由于CSS中处理font-weight的特殊方式，这个匹配绝不会失败
    4. 之后再针对font-size进行匹配。必须在某个可忍受的范围内匹配，这种忍受程度要由用户代理定义
3. 如果在第2步中未匹配任何字体，用户代理就会在这个字体系列中查找下一个候选字体。如果找到了，则对改字体重复第2步
4. 假设找到一个通用匹配，但是其中不包含显示给定元素需要的一切（这种字体没有版权符号）用户代理就要回到第3步，再搜索另一个候选字体，然后再通过第2步来验证这种字体是否匹配
5. 如果没有找到匹配，而且所有候选字体都已经试过了，用户代理就会为给定的通用字体系列选择默认字体，尽可能正确地显示这个元素
注：对每个元素，用户代理要检查该元素中的字符，并确定样式字体是否能够提供匹配的字符。假设段落中有一个字符样式字体不能提供，用户代理可能忽略这个字符，或者查找另外一个能满足该元素显示需求的字体
#### font-face规则
CSS2引入了一种方法，可以通过@font-face规则对字体匹配有更多控制（已经从CSS2.1去除）
确定文档中使用字体的4种方法
* 字体名匹配
要匹配字体名，用户dialing会使用与所请求字体有相同系列名的一种可用字体。（这种字体的外观和度量与所请求的字体可能并不相同）
* 智能字体匹配
在这种情况下，用户代理使用外观上与所请求字体最接近的一种可用字体；用于匹配两种字体的信息包括字体种类（文本或符号）、是否有上下短线、加粗、大写字母高度、x-height、上升、下降、倾斜等等
* 字体合成
用户代理也可以选择实时地生成一个字体，使其外观和度量与@font-face规则中指定的描述相匹配（如果要保留指定字体的所有布局特征，合成需要准确的宽度度量和字符来完成字形和位置信息替换；合成信息包括匹配信息，通常需要比某些匹配机制使用更准确的参数值）
* 字体下载
采用这种方法，用户代理可以在文档中下载一个远程字体来使用（字体文件往往很大，这就会延迟文档的显示，或者至少延迟最终输出）
## 文本属性
文本放在哪里，文本的外观是怎样的
文本是内容，而字体用于显示这个内容
使用文本属性，可以控制文本相对于该行余下内容的位置、使其作为上标、加下划线，以及改变大小写等
### 缩进和水平对齐
#### 缩进文本
将Web页面上一个段落的第一行缩进，这是一种最常用的文本格式化效果（去除段落间的空行是第二常用的方法）
实现缩进：透明图像；完全非标准的SPACER标记；在CSS中，使用text-indent属性
注：如果想把一个行内元素的第一行“缩进”，可以用左内边距或外边距创造这种效果；text-indent可以为负值--悬挂缩进
注：在为text-indent设置负值时要当心：可能会超出浏览器窗口的左边界。为了避免出现这种现实问题，建议针对负缩进再设置一个外边距或一些内边距
注：百分数相对于父元素的宽度；即时插入了行分隔符，这种缩进也只应用与一个元素的第一行
注：在CSS2.1之前，text-indent总是继承计算值，而不是声明值
#### 水平对齐
text-align会影响一个元素中文本行相互之间的对齐方式
西方语言都是从左向右读，text-align默认值是left。文本在左边界对齐，右边界呈锯齿状（称为“从左到右”文本）。对于希伯来语和阿拉伯语之类的语言，text-align则默认为right
text-align初始值：用户代理特定的值；还可能取决于书写方向
注：<center>不仅影响文本，还会把整个元素居中。text-align不会控制元素的对齐，而只影响其内部内容
注：justiy是两端对齐，文本行的左右两端都放在父元素的内边界上，然后，调整单词和字母间的间隔，使各行的长度恰好相等（两端对齐文本在打印领域很常见）；在CSS中要由用户代理（而不是CSS）来确定两端对齐文本如何拉伸，以填满父元素左右边界之间的空间
注：有些浏览器可能只在单词间增加额外的空间，而另外一些浏览器可能会平均分布字母间的额外空间（不过CSS规范特别指出，如果letter-sapcing属性指定为一个长度值，“用户代理不能进一步增加或减少字符间的空间”），还有一些用户dialing可能会减少某些行的空间，使文本挤得更紧密--所有这些做法都会影响元素的外观，甚至改变其高度，这取决于用户代理的对齐选择影响了多少文本行
注：CSS也没有指定应当如何处理连字符（大多数两端对齐文本都使用连字符将长单词分开放在两行上，从而缩小单词间的间隔，改善文本行外观）
### 垂直对齐
#### 行高
line-height属性是指文本行基线之间的距离，而不是字体大小，它确定了将各个元素框高度增加或减少是多少
line-height值和字体大小之差就是行间距，它控制了行间距
在应用到块级元素时，line-height定义了元素中文本基线之间的最小距离
line-height并不影响替换元素的布局，不过确实可以应用到替换元素
#### 构造文本行
文本行中每个元素都会生成一个内容区，这由字体的大小确定。这个内容区则会生成一个行内框，如果不存在其他因素，这个行内框就完全等于该元素的内容区。由line-height长沙的行间距就是增加或减少各行内框高度因素之一
注：line-height的计算值减去font-size的计算值。这个值是总的行间距。（可能是一个负值）然后，行间距再除以2，将行间距的一半分别应用到内容区的顶部和底部。其结果就是该元素的行内框
#### 指定lien-height值
如果使用默认值normal，用户dialing必须计算行间距的垂直空间。不同用户代理计算出的值可能不同，不过通常是字体大小的1.2倍，这使得行框要高于戈丁元素的font-size值
#### 行高和继承
使用light-height缩放因子解决值继承问题

#### 垂直对齐文本
在CSS中，vertical-align属性只应用与行内元素和替换元素。vertical-align属性不能继承
vertical-align属性应用于行内元素和表单元格；应用到表单元格时，只能识别baseline、top、midlle和bottom等
注：vertical-align不影响块级元素中内容的对齐。不过可以用它来影响表单元格中元素的对齐
#### 基线对齐
基线对齐要求一个元素的基线与其父元素的基线对齐；如果一个垂直对齐元素没有基线（图像或表单输入元素或者其他替换元素），那么该元素的底端与其父元素的基线对齐
这个对齐规则使得一些Web浏览器总把替换元素的底边放在基线上，即使该行中没有其他文本
#### 上标和下标
vertical-align:sub声明会使一个元素变成下标，这意味着其基线（或者如果这是一个替换元素，则是其底端）相对其父元素的基线降低（规范中并没有定义元素降低的距离，所以对于不同的用户dialing，这个距离可能有所不同）
supper与sub相反，它将元素的基线（或替换元素的底端）相对于父元素的基线升高。同样地，文本升高的距离取决于具体的用户代理
sub和supper不会改变元素的大小
#### 底端对齐
vertical-align:bottom将元素行内框的底端与行框的底端对齐
vertical-align:text-bottom是指行内文本的底端（替换元素或任何其他类型的非文本元素会忽略这个值）。对于这些元素，将考虑一个“默认”的文本框。这个默认文本框由父元素的font-size得到。要对齐的元素的行内框底端再与这个默认文本框的底端对齐
#### 顶端对齐
vertical-algin:top的效果与bottom刚好相反。类似地，vertical-align:text-top则与text-bottom的作用相反
#### 居中对齐
middle往往（并不总是）应用于图像。middle会把行内元素框的中点与父元素基线上方0.5ex处的一个点对齐
#### 百分数
使用百分数会把元素的基线（或替换元素的底边）相对于父元素的基线升高或降低指定的两。指定的变分数要计算为该元素Line-height的百分数，而不是相对于其父元素的line-height
#### 长度对齐
根据指定长度垂直对齐：它把一个元素升高或降低指定的距离
垂直对齐的文本不会成为另一行的一部分，它也不会覆盖其他行中的文本
所有垂直对齐的元素都会影响行高。行框的高度要足以包含最高行内框的顶端和最低行内框的底端。这包括因垂直对齐上升或下降的行内框

### 字间隔和字母间隔
#### 字间隔
word-spacing属性接受一个正长度值或负长度值。这个长度值会增加到字之间的标准间隔。默认值与设置值为0是一样的
用最简单的CSS术语来讲，“字”可以是任何非空白字符组成的串，并由某种空白符包围。支持CSS的用户代理不一定能确定一个给定语言中哪些是合法的字，而哪些不是。采用象形文字的语言或非罗马书写体往往无法指定字间隔
#### 字母间隔
字母间隔与字间隔的真正区别是字母间隔修改的是字符或字母之间的间隔。输入的长度值会使字母间的间隔增加或减少指定的量
可以使用letter-spacing来突出强调效果
#### 间隔和对齐
word-spacing的值可能受到text-align属性值的影响。如果一个元素是两端对齐的，字母和字之间的空间可能会调整，以便文本在整行中刚好放下。这可能改变创作人员用worrd-spacing声明的字间隔。
如果为letter-spacing指定一个长度值，字符间隔不会受text-align影响，但是如果letter-spacing的值是normal，字符间的间隔就可能改变，以便将文本两端对齐
一般地，一个元素的子元素会继承该元素的计算值。无法为word-spacing或letter-spacing定义一个可继承的缩放因子来取代计算值（像line-height那样）
### 文本转换
使用text-transform属性可以处理文本的大小写
默认值none对文本不做任何改动，将使用源文档中原有的大小写。
capitalize只对每个单词的首字母大写。不同的用户代理可能会用不同的方法来确定单词从哪里开始相应地确定哪些字母要大写。CSS只要求用户代理确保每个单词的首字母大写，可以忽略单词的余下部分
### 文本装饰
underline--下划线  overline--上划线  line-through--贯穿线 blink--文本闪烁
可以在一个规则中结合多种装饰--空格分隔
#### 怪异的装饰
* text-decoration不能继承。没有继承性意味着文本上画的任何装饰线与父元素的颜色相同。即使后代元素本身有其他颜色
* text-decoration与vertical-align结合时
注：在实际中，尽管不该去掉子元素的下划线，但有些Web浏览器确实会这么做
注：在一个元素上设置文本装饰意味着整个元素都有同样的颜色装饰，即使子元素有不同颜色。为了使装饰颜色与一个元素匹配，必须显示地声明其装饰
### 文本阴影
CSS2包含一个属性来为文本增加阴影，不过这个属性并没有在CSS2.1中保留，因为在CSS2.1完成前没有一个浏览器对此提供了充分的支持
每个阴影由一个颜色和3个长度值来定义--前两个长度值确定了阴影与文本的偏移距离，第三个长度值可选，定义了阴影的“模糊半径”
前两个长度值--相对文本向右偏移距离和向下偏移距离
模糊半径定义为从阴影轮廓到模糊效果边界的距离。具体的模糊方法并未定义，所以不同的用户代理可能会有不同的效果
### 处理空白符
使用这个属性，可以影响浏览器处理字之间和文本行之间空白符的方式。默认的XHTML处理已经完成了空白符处理：他会把所有空白符合并为一个空格
如果将white-space设置为pre，受这个属性影响的元素中，空白符的处理就有所不同，空白符不会被忽略；nowrap会防止文本元素的文本换行，除非使用了一个br元素
CSS2.1引入了值pre-wrap和pre-line。pre-wrap使元素中的文本会保留空白符序列，但是文本行会正常地换行，并且源文本中的行分隔符以及生成的行分隔符也会保留。pre-line会合并空白符，但保留换行符
### 文本方向
希伯来语和阿拉伯语从右向左读，CSS2引入了一个顺序来描述其方向
direction属性影响块级元素中国文本的书写方向、表中列布局方向、内容水平填充其元素框的方向，以及两端对齐元素中最后一行的位置
对于行内元素，只有当unicode-bidi属性设置为embed或bidi-override时才会应用direction属性
**unicoe-bidi**
* normal--元素不会对双向算法打开附加的一层嵌套。对于行内元素，顺序的隐式重拍会跨元素边界进行
* embed--如果是一个行内元素，这个值会对于双向算法打开附加的一层嵌套。这个嵌套层方向由direction属性指定。会在元素内部隐式地完成顺序重排。这对应于在元素开始处增加一个LRE或RLE，并在元素的最后增加一个PDF
* bidi-override--这会为行内元素创建一个覆盖。对于块级元素，将为不再另一块的行内后代创建一个覆盖。这说明，顺序重排在元素内部严格按direction属性进行；忽略了双向算法的隐式部分。这对应于在元素开始处增加一个LRO或RLO，并在元素最后增加一个PDF
## 基础视觉格式化
如果全面地掌握了CSS中视觉表现模型是如何工作的，就能确定一种行为到底是CSS所定义表现引擎的正确结果（尽管出乎意料），还是一个需要报告的bug
### 基本框
CSS假定每个元素都会生成一个或多个矩形框，这些称为元素框。各元素框中心有一个内容区。这个内容区周围有可选的内边距、边框和外边距。.
可以使用多种属性设置各种外边距、边距和内边距（margin-left或border-bottom）。内容的背景（例如某种颜色或平铺图像）也会应用到内边距。外边距通常是透明的，从中可以看到父元素的背景。内边距不能是负值，但是外边距可以
边框使用已定义样式生成，如solid或inset，边框的颜色使用border-color属性设置。如果没有设置颜色，那边边框将取元素内容的前景色
边框与内容和内边距有相同背景。边框宽度绝对不能为负
不同类型的元素格式化时存在着差别
#### 包含块
每个元素都相对于其包含块摆放，包含块就是一个元素的“布局上下文”。CSS2.1定义了一些列规则来确定元素的包含块
对于正常的西方语言文本流中的一个元素，包含块由最近的块级祖先框、表单元格或行内块祖先框的内容边界构成
行内元素的摆放不直接依赖于包含块
#### 基本术语
* 正常流：这是指西方语言文本从左向右、从上向下显示，这也是传统HTML文档的文本布局（在非西方语言中，流的方向可能不同）。大多数元素都在正常流中，要让一个元素不在正常流中，唯一的办法就是使之成为浮动或定位元素
* 非替换元素：如果元素的内容包含在文档中，则称之为非替换元素
* 替换元素：这是指用作为其他内容占位符的一个元素
* 块级元素：这是指段落、标题或div之类的元素。这些元素在正常流中时，会在器框之前和之后生成“换行”，所以处于正常流中的块级元素会垂直摆放。通过声明display:block，可以让元素生成块级框
* 行内元素：这是指strong或span之类的元素。这些元素不会在之前或之后生成“行分隔符”，它们是块级元素的后代。通过声明display:inline，可以让元素生成一个行内框
* 根元素：位于文档树顶端的元素。在HTML文档中，就是元素html。在XML文档中，则可以是改语言允许的任何元素
### 块级元素
一个元素的width被定义为从左内边界到右内边界的距离，height则是从上内边界到下内边界的距离
不同的宽度、高度、内边距和外边距相结合，就可以确定文档布局
大多数情况下，文档的高度和宽度由浏览器自动确定，这要基于可用的显示区域和其他一些因素。

#### 水平格式化
正常流中块级元素框的水平部分总和就等于父元素的width
#### 水平属性
水平格式化的“7大属性”是：margin-left、border-left、padding-left、width、padding-right、border-right和margin-right。这些属性与块级框的水平布局有关。这7个属性的值加在一起必须是元素包含块的宽度
在这7个属性中，只有3个属性可以设置为auto：元素内容的width，以及左、右外边距。其余属性必须设置为特定的值，或者默认宽度为0
width必须设置为auto或某种类型的非负值
注：CSS允许浏览器为width设置一个最小值；块级元素的width不能小于这个值。对于不同的浏览器，这个最小值可能不同，因为在规范中对此没有定义
#### 使用auto
如果设置值width、margin-left或margin-right中的某个值为auto，而余下两个属性为特定的值，那么设置为auto的属性会确定所需的长度，从而使元素框的宽度等于父元素的width
如果所有者三个属性都设置为非auto的某个值（格式化属性过分受限），此时总会把margin-right（从左往右读的语言）强制为auto
##### 不只一个auto
这三个属性如果有两个设置为auto。如果两个外边距都设置为auto，它们会设置为相等的长度）
如果将某个外边距以及width设置为auto。设置为auto的外边距会减为0
如果3个属性都设置为auto：两个外边距都会设置为0，而with会尽可能宽。这种结果与默认情况相同
注：由于水平外边距不会合并，父元素的内边距、边距和外边距可能影响其子元素。这种效果是间接的
#### 负外边距
按照CSS规范，用户代理不要求完全支持负外边距。规范指出：“外边距属性允许为负值，不过可以有一些特定于具体实现的限制”
只要所有属性都大于或等于0的，元素就不会大于其父元素的内容区。通过指定负外边距可以得到更宽的子元素；可以将一个外边距设置为auto，如果其他属性的值要求该外边距为负，以便满足元素不能比其包含块更宽的需求
注：如果左外边距为负，不仅段落会超出div的边框，还会超出浏览器窗口本身的边界
#### 百分数
百分数值是相对于包含块的宽度
边框宽度不能是百分数
基本原则是：只使用百分数将无法创建完全灵活的元素布局（即所有属性都可设置），除非不想使用边框
#### 替换元素
非替换块元素的所有规则同样适用于替换块元素。只有一个例外，如果width为auto，元素的宽度则是内容的固有宽度（可以为width指定一个特定值覆盖这个规则；如果一个替换元素的width不同于其固有宽度，那么height值也会成比例变化，除非height自己也显示设置为一个特定值；如果设置了height，但width保持为auto，则width将随height的变化成比例调整）

#### 垂直格式化
#### 合并垂直外边距
li {margin-top: 10px; margin-bottom:15px}每个列表项有10像素的上外边距和15像素的下外边距。不过显示这个列表时，相邻列表项之间的距离是15px，而不是25px。（多个外边距中较小的一个会被较大的一个合并）
#### 负外边距
负外边距确实对垂直格式化有影响，而且它们会影响外边距如何合并。如果垂直外边距都设置为负值，浏览器会取两个外边距绝对值的最大值。如果一个正外边距与一个负外边距合并，会从正外边距减去这个负外边距的绝对值
注：如果由于负外边距而导致元素彼此重叠，很难区分哪些元素在上面。（如果使用背景色，其内容可能会被后面元素的背景色覆盖，因为浏览器总会按从前到后的顺序显示元素，所以文档中后出现的正常流元素可能会覆盖较早出现的元素--如果这两个元素重叠）

#### 列表项
列表项有自身的一些特殊规则。列表项前面的标志并不是列表项内容区的一部分
CSS2引入了marker-offset等属性对这些标志相对于文档布局的放置和效果（在CSS2.1去除了）
与一个列表项元素关联的标志可能在列表项内容之外，也可能处理为内容开始处的一个内联标志，这取决于属性list-style-position的值
不论如何改变列表的样式，标志与内容边界的距离都不变。有时，标志可能会放在列表元素本身之外
### 行内元素
行内元素：em标志和a标志，这两个标志都是非替换元素，另外图像也属于行内元素，不过图像是替换元素
#### 行布局
**基本术语**
* 匿名文本--匿名文本是指所有未包含在行内元素中的字符串。空格也是匿名文本的一部分
* em框--em框在字体中定义，也称为字符框。实际的字形可能比其em框更高或更矮
* 内容区--在非替换元素中，内容区可能有两种，CSS2.1规范允许用户代理选择其中任意一种。内容区可以是元素中各个字符的em框串在一起构成的框，也可以是由元素中字符字形描述的框。在替换元素中，内容区就是元素的固有高度再加上可能有的外边距、边框或内边距
* 行间距--行间距是font-size值和line-height值之差。行间距只应用于非替换元素
* 行内框--这个框通过向内容区增加行间距来描述。对于非替换元素，元素行内框的高度刚好等于line-height的值。对于替换元素，元素行内框的高度则恰好等于内容区的高度
* 行框--这是包含该行中出现的行内框的最高点和最低点的最小框。
注：非替换元素的内边距、边框和外边距对行内元素或其生成的框没有垂直效果；也就是说，它们不会影响元素行内框的高度（也不会影响包含该元素的行框的高度）。替换元素的外边距和边框确实会影响该元素行内框的高度，相应地，也可能影响包含该元素的行框的高度

**构造行框**
1. 确定行中各元素行内框的高度
    * 得到个行内非替换元素及不属于后代行内元素的所有文本的font-size值和line-height值，再将line-height减去font-size，这样就得到了框的行间距。这个行间距除以2，将其一般分别应用到em框的顶部和底部
    * 得到个替换元素的height、margin-top、margin-bottom、padding-top、padding-bottom、border-top-width和border-bottom-width值，把它们加在一起
2. 对于各内容区，确定它在整行基线的上方和下方分别超出多少。必须知道各元素及匿名文本各部分的基线的位置，还要知道该行本身基线位置；然后把它们对齐。另外对于替换元素，要将其底边放在整行的基线上
3. 对于制定了vertical-align值的元素，确定其垂直偏移量
4. 知道了所有行内框会放在哪里，再计算最后的行框高度
#### 行内格式化
行的高度（或行框的高度）由其组成元素和其他内容（如果文本）的高度决定
line-height实际上只影响行内元素和其他行内内容，而不影响块级元素，至少不会直接影响块级元素（也可以为一个块级元素设置line-height值，但是这个值只是应用到块级元素的内联内容时才会有视觉影响）
从某种程序上讲，块级元素中包含的各文本行本身都是行内元素，每个文本行从段落继承了样式。
CSS规范，在块级元素上声明line-height会为该块级元素的内容设置一个最小行框高度
#### 行内非替换元素
行内框可以小于内容区（当line-height小于font-size时）
#### 垂直对齐
垂直对齐影响行框高度

#### 管理line-height
影响元素的line-height避免内容重叠
对font-size有改变的元素结合使用em单位
边框在内容区的基础上增加

**基线与行高**
* 各行框的具体高度取决于其组成元素相互之间如何对齐。这种对齐往往很大程度上依赖于基线落在各元素（或匿名文本）中的哪个位置，因为这个位置确定了其行内框如何摆放
* 基线在各em框中的位置对于不同的字体是不同的。这个信息内置在字体文件中，除非直接编辑字体文件，否则无法修改
* 要得到一致的基线间隔，这更像是一门艺术而不只是一门科学
#### 缩放行高
设置line-height的最好办法是使用一个原始数字值。因为这个数会成为缩放因子，而该因子是一个继承值而非计算值
注：大多数字体在字符字形之间还显示有一点空间，因为字符往往比其em框要小。只有script（“cursive”）字体例外，其字符字形往往大于其em框
#### 增加框属性
内边距、外边距和边框都可以应用于行内非替换元素。行内元素的这些方面根本不会影响行框的高度
注：CSS2.1中明确指定了外边距的放置：它定义了margin-top和marigin-bottom（可以应用到不是行内非替换元素的所有其他元素），而不是简单地说用户代理应当忽略上、下外边距
注：尽管内边距和外边距（以及边框）不影响行高，但是他们确实能影响一个元素内容的布局，可能将文本推离其左右两端
注：CSS2.1明确指出行框按文档的顺序绘制：“这会导致后续行的边框在前面行的边框和文本上绘制”。另一方面，CSS2允许用户代理“切掉”边框和内边距区（也就是不现实边框和内边距“。）
#### 行内替换元素
一般认为行内替换元素（如图像）有固定的高度和宽度。有固定高度的替换元素可能导致行框比正常要高，会让行框的高度恰好能包含替换元素（以及所有框属性），会用替换元素整体（包括内容、外边距、边距和内边距）来定义元素的行内框

**字形与内容区**
尽力避免行内非替换元素的背景重叠（对于大多数字体，其em框的高度与字符字形的高度都不一致）
CSS2.1中指出：“内容区的高度应当基于字体”，但是这个规范并没有指定如何基于字体确定内容区的高度。用户代理可能使用em框，也可能使用字体的最大上升变形和下降变形
换句话说，一个行内非替换元素的“绘制区”要由用户代理来决定。因此尽管可以为行内非替换元素指定line-height为1em，但其背景还是有可能与其他行的内容重叠
行内替换元素的line-height值虽然对图像的行内框没有任何影响，但是还是需要这个值，从而在垂直对齐时能正确地定位元素--vertical-align的百分数值要相对于元素的line-height来计算
对于其他替换元素，将line-height值传递到该替换元素中的后代元素可能很重要。SVG图像就是这样一个例子，它使用CSS对图像中的所有文本设置样式
##### 增加框属性
外边距、内边距和边框会影响行框的高度，因为他们要作为行内替换元素的行内框的一部分
外边距也在行框中，不过外边距有自己的问题。设置正外边距会使替换元素的行内框更高；设置负外边距会减少替换元素行内框的大小。负外边距是使行内替换元素挤入其他行的唯一办法
##### 替换元素和基线
替换元素并没有自己的基线。如果向替换元素增加下内边距、外边距或边框，内容区会上移
如果一个表单元格中只有一个图像，这个图像要让表单元格足够高，从而能把包含该图像的行框包含在内（还是会出现大小调整）
这种行为并不仅限于表单元格中的图像；只要一个行内替换元素是块级元素或表单元格元素中的唯一后代，都有这种行为（替换元素放在基线上）

**解决方案**
* 使间隔图像称为块级元素，这样它们就不会生成行框
* 将包含图像的表单元格的font-size和line-height都设置为1px
注：有些浏览器知识把内容区的底端放在基线上，而忽略负的下外边距

**行内模型历史追溯**
设计者尽力创建这样一个模型，（默认地）它不会导致行内图像与其他文本行重叠（创作人员基线间距离应该固定）
#### 改变元素的显示
可以为属性display设置一个值来影响用户代理显示的方式
##### 改变角色
将链接作为块级元素，就可以像处理div元素一样设置样式，这有一个好处，即整个元素框会成为链接的一部分。因此，如果用户的鼠标指针停留在元素框的某处，他就能点击这个链接
注：改变的只是元素的显示角色，而不是其本质。换句话说，让一个段落生成行内框并不会把这个段落真正变成一个行内元素；行内元素可能是一个块元素的后代，但是反过来则不行
##### 行内块元素
inline-block是CSS2.1中新增的，是块级元素和行内元素的混合。
行内块元素作为一个行内框与其他元素和内容相关。实际上，行内块元素会作为替换元素放在行中。这说明，行内块元素的底端默认地位于文本行的基线上，而且内部没有行分隔符
在行内块元素的内部，会像块级元素一样设置内容的格式
注：width和text-align不能用于行内元素；如果行内块元素的width未定义，或者显示声明为auto，元素框会收缩以适应内容。行内框也会这样做，不过行内框可能会跨多个文本行，而行内块元素不能
##### run-in元素
CSS2引入了一个值run-in，这可以使某些块级元素称为下一个元素的行内部分。（这种功能对于某些标题效果很有用）
在CSS中，只需要改变元素的display值，并使下一个元素框作为块级元素框，就可以是元素称为run-in元素。
如果一个元素生成run-in框，而且该框后面是一个块级框，那么该run-in元素将成为块级框开始处的一个行内框
注：run-in框格式化为另一个元素中的行内框，它们仍然从文档中的父元素继承属性，而不是说它们放在哪个元素中就从哪个元素继承属性
注：只有当run-in框后面是一个块级框时run-in才起作用。如果不是这样，run-in框本身将成为块级框
##### 计算值
如果元素是浮动元素或定位元素，display的计算值可以改变。如果为一个根元素声明display值，计算值也可以改变。实际上，display、position和float值会以很有意思的方式互相影响
对于根元素，如果声明为值inline-table或table，都会得到计算值table，声明为none时则会得到同样的计算值。所有其他display值都计算为block
## 内边距、边框和外边距
CSS运行为段落、标题、div、锚和图像（几乎是Web页面可以包含的一切）定义边框。这些边框可以将一个元素与其他元素区别开，强调其外观，将某类数据标志位有改变，或者达到其他效果
### 基本元素框
所有文档元素都生成一个矩形框，这称为元素框，它描述了一个元素在文档布局中所占的空间大小。每个框影响着其他元素框的位置和大小
#### 宽度和高度
宽度和高度不能应用到行内非替换元素
正常流中的元素很少有设定的高度，高度由元素的内容来定，而不是创作人员确定
#### 外边距和内边距
有3中办发可以在元素外围生成额外的空间：可以增加内边距，或者增加外边距，还可以同时增加聂编剧和外边距。背景会延伸到内边距中，但不会延伸到外边距
### 外边距
大多数正常流元素间出现的间隔都是因为存在外边距。设置外边距会在元素外创建额外的“空白”（指不能放其他元素的区域），而且在这个区域可以看到父元素的背景
外边距margin默认值为0
注：在实际中，浏览器对许多元素已经提供了预定的样式，外边距也不例外。在支持CSS的浏览器中，外边距会在每个段落元素的上面和下面生成“空行”。因此，如果没有为p元素声明外边距，浏览器可能会自己应用某个外边距
#### 长度值和外边距
margin可以指定四个值，这四个值是从上开始围着元素顺时针旋转的
#### 百分数和外边距
百分数是相对于父元素的width计算的
正常流中的大多数元素都会足够高以包含其后代元素（包括其外边距）。如果一个元素的上下外边距是父元素的height的百分数，就可能导致一个无限循环。规范的作者没有简单的忽略上下外边距百分数，而是决定让它与父元素的width相关，不会根据其后代元素的width而改变
注：如果对一个文档设置样式，使其元素使用百分数外边距，当用户修改浏览器窗口的宽度时，外边距会随之扩大或缩小；没有为元素声明width时，元素框的总宽度（包括外边距）取决于父元素的width。这可能得到“流式”页面，即元素的外边距会扩大或缩小以适应父元素（或显示画布）的实际大小
#### 值复制
CSS定义了一些规则，允许为外边距指定少于4个值。规则如下：
* 如果缺少左外边距的值，则使用右外边距的值
* 如果缺少下外边距的值，则使用上外边距的值
* 如果缺少右外边距的值，则使用上外边距的值
#### 单外边距属性
margin-top margin-right marigin-bottom margin-left将只设置该边上的外边距，而不会直接影响其他外边距
#### 负外边距和合并外边距
可以为元素设置负外边距。这会导致元素框超出其父元素，或者与其他元素重叠，但并不违反框模型
负的下外边距导致其父元素的底端向上拉，使得段落超出其父元素底端。正常流中垂直相邻外边距会合并
注：浏览器对相邻兄弟选择器的支持还很有限
#### 外边距和行内元素
外边距可以应用到行内元素，不过由于在向一个行内非替换元素应用外边距，它对行高没有任何影响。由于外边距实际上是透明的，所以这个声明没有任何视觉效果
注：对于只包含文本的行，能改变行间距的属性只有line-height、font-size和vertical-align
注：这只对行内非替换元素的上下边成立，左右边则是另一回事，左右外边距是可见的
如果向行内非替换元素应用负外边距，元素的左右两端可能与其他内容重叠
为替换元素设置的外边距确实会影响行高，可能会使行高增加或减少，这取决于上下外边距值。行内替换元素的左右外边距与非替换元素的左右外边距作用一样
### 边框
元素外边距内就是元素的边框。元素的边框就是围绕元素内容和内边距的一条或多条线。
每个边框都有3个方面：其宽度或粗细、其样式或外观，以及颜色
边框宽度默认为medium，这个值没有明确定义，不过通常是2个像素
尽管如此，你不一定能看到边框，因为边框的默认样式为none，这样就不会有边框（不存在边框还会重置width值）
默认的边框颜色是元素本身的前景色。如果没有为边框声明颜色，它将与元素的文本颜色相同（如果一个元素没有任何文本，假设它有一个表，其中只包含颜色，那么该表的边框颜色就是其父元素的文本颜色）
#### 边框和背景
CSS规范清楚地指出元素的背景会延伸到边框边界之外，因为规范中提到，边框绘制在“元素的背景之上”（有些边框是“间断的”）
CSS2.1明确指出元素的背景是内容、内边距和边框区的背景。
#### 有样式的边框
样式控制着边框的显示
最不可预测的边框样式是double。它定义为两条线的宽度再加上这两条线间的空间等于border-width值（CSS规范没有定义两条线粗细和线间距离）
边框样式的外观总是以某种方式基于边框的颜色
##### 多种样式
可以为给定边框定义多个样式，同样采用TRBL的顺序
##### 单边样式
只为元素框的一般设置边框样式
#### 边框宽度
使用border-width为边框指定宽度

**根本没有边框**
当边框样式设置为none时，不仅边框的样式没有了，其宽度也会变成0。边框消失
希望边框出现时必须设置边框样式，基于边框样式再去设置边框其他属性
#### 边框颜色
使用border-color设置边框颜色
也存在单边颜色属性

**透明边框**
使用transparent（CSS2引入）可以创建一个不可见边框。这可以需要的时候使其可见

**简写边框属性**
可以向单边同时指定宽度、样式和颜色（顺序不重要；不能进行值复制）
#### 全局边框
所有边框中最简短的简写属性：border
使用border的缺点在于，只能定义“全局”的样式、宽度和颜色（为border提供的值将完全相等地应用到所有4个边；如果少一个值会自动填入默认值）
#### 边框和行内元素
不论行内元素的边框指定怎样的宽度，元素的行高都不会改变
如果应用一个左边框或右边框，不仅该边框可见，而且文本会在其旁边显示（不会覆盖）
### 内边距
元素的内边距在边框和内容区之间，控制这个区的最简单的属性为padding（内边距绝对不能为负）
元素的背景延伸到内边距，它还会延伸到边框的外边界，不过背景到达边框之前必须先经过内边距
默认地，元素没有内边距，内边距不合并
#### 百分数值和内边距
元素内边距设置百分数也是相对于父元素的width计算
#### 单内边距
CSS提供了一些属性来设置框的单边内边距，而不影响其他边上的内边距
#### 内边距和行内元素
内边距同样不会改变行高

**内边距与替换元素**
可以向替换元素应用内边距，不论替换元素是块级元素还是行内元素，内边距都会围绕其内容，背景色将填入该内边距
注：很多较老的浏览器不像图像应用内边距，包括Windows平台的IE5
注：在CSS2.1中，关于如何对表单元素设置样式还存在一些混淆。例如，复选框的内边距在那里就不是很清楚。（有些浏览器--如Mozilla会忽略表单元素的内边距）
## 颜色和背景
### 颜色
设计页面时，要在开始前先做好计划；选择的类名最好描述其中包含的信息类型
CSS中实际上只有一种颜色类型，即纯色
在CSS中，可以为任何元素设置前景和背景色
一般来说，前景是元素的文本，不过前景还包括元素周围的边框（影响元素前景色：可以使用color属性，也可以使用某个边框属性设置边框颜色）
###前景色
要设置一个元素的前景色，最容易的办法是利用属性color
对于非替换元素，color设置了元素中文本的颜色
通常最好同时设置前景和背景色
#### 替换属性
color可以替换HTML3.2的BODY属性TEXT、LINK、ALINK和VLINK
#### 影响边框
color值还可以影响元素周围的边框
利用边框可以影响图像的前景色。
#### 影响表单元素
为select指定color可能还会设置select元素周围边框的颜色，也可能不会，这完全取决于用户代理及其默认样式
CSS1无法区分不同类型的input元素；许多用户代理不支持属性选择器
#### 继承颜色
color是可以继承的，不过浏览器的值会比继承的值更优先
### 背景
元素的背景区包括前景之下到边框外边界的所有空间；因此，内容库和内边距都是元素背景的一部分，且边框画在背景之上
CSS运行应用纯色作为背景，也允许使用背景图像创建相当复杂的效果
#### 背景色
类似于设置前景色，可以为元素的背景声明一个颜色；背景色默认值为transparent，且不能继承
注：创作人员样式和读者样式有可能结合，创作人员指定的颜色与用户指定的颜色可能发生交互
#### 背景图像
在HTML3.2中，可以通过使用BODY属性BACKGROUND向文档的背景关联一个图像；这回事用户代理加载文件，然后把它“平铺”在文档背景中，沿水平方向和垂直方向重复放置这个图像，填满文档的整个背景

**使用图像**
把图像放入背景，需要使用属性background-image；指定背景图像的同时可以再指定一个背景色
甚至可以向textareas和select列表等替换元素的背景应用图像，不过并不是所有用户代理都能很好地处理这种情况
注：所有背景属性都不能继承

**关于背景的良好实践**
如果出于某种原因无法加载图像，用户代理就会使用指定的背景色取代图像
注：对于有alpha通道的图像格式，如PNG，可能会部分或完全透明，这会导致图像与背景色结合
#### 有方向的重复
background-repeat可以控制图像平铺的方向
#### 背景定位
可以通过background-positon控制图像在背景中的位置
每个包含图像的背景都从一个图像开始，再根据background-repeat的值重复（或不重复）。这个起点称为原图像
根据back-ground-position，将相对于元素的内边距边界放置原图像（放置图像的上下文是内边框边界，尽管背景区会延伸到外边框边界；并非所有浏览器都能正确地放置图像）
注：尽管有图像放置的上下文，不过完全平铺的背景图像确实会填充边框区的背景，因为平铺图像会在4个方向上延伸。

**关键字**
（根据规范）位置关键字可以按任何顺序出现，只要保证不能超过两个关键字--一个对应水平方向，另一个对应垂直方向；如果只出现了一个关键字，则认为另一个关键字是center
注：Netscape6.x系列有一个bug，为了避免这个bug，要确保关键字指定水平放置，然后是垂直放置。

**百分数值**
百分数值同时应用于元素和原图像；如果用百分数设置位置，水平值总是先出现。如果只指定了一个关键字，另一个关键字则假设为center。background-position的默认值是0% 0%

**长度值**
在为原图像的位置提供长度值时，这些长度值将解释为从元素内边距区左上角的偏移。偏移点是原图像的左上角；这与百分数值大不相同，因为偏移只是从一个左上角到另一个左上角的偏移
注：在CSS2.1之前的版本中，不能将关键字与其他值混合使用
注：如果使用长度值或百分数值，可以使用负值将原图像拉出元素的背景区；理论上负百分数值也是允许的，不过存在两个问题。第一个问题是用户代理可能有限制，无法识别。另一个问题是，负百分数值计算起来很有意思（如，原图像和元素很可能大小不同）
注：平铺模式将从background-position指定的位置开始
#### 有方向的重复（深入）
background-position造成的唯一差别是确定平铺从哪里开始；当背景从中心重复时，会在各边界得到一致的“裁剪”效果。平铺从内边距左上角开始，裁剪是不一致的
#### 关联
将一个图像放在body元素的中心，如果是一个相当长的文档，这个背景图像最开始对读者可能不可见。毕竟，浏览器只是在文档上开了一个窗口
通过使用属性background-attachment，可以声明原图像相对于可视区是固定的，因此不会受滚动的影响（原图像不会随文档滚动；原图像的放置由可视区大小确定）

**有意思的效果**
如果一个背景图像已经固定，它会相对于可视区定位，而不是相对于包含该图像的元素定位
一个背景如果是固定的，原元素会根据视窗定位。因此，背景模式都从视窗的左上角开始平铺，而不是从单个元素的左上角开始。因此可以实现背景的理想对齐
对于分页媒体（如打印输出），每个页面都生成自己的视窗。因此固定关联背景在打印输出的每一页上都应当显示

**汇总**
背景属性可以汇总到一个简写属性：background。顺序任意
如果背景位置有两个值，它们必须一起出现，而且如果这两个值是长度或百分数，则必须按水平值再前垂直值再后的顺序

## 浮动与定位
定位的思想很简单，它允许你定义元素框相对于正常位置应该出现在哪里，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置
### 浮动
“浮动”一词源自文档“HTML2.0”的扩展，其中指出：ALIGN选项有所增补，对此需要做一些解释。首先来看值“left”和"right"。可以把这些对齐方式看作是全新的浮动图像类型
注：过去，只可能浮动图像（某些浏览器可能还支持表的浮动）。但CSS允许浮动任何元素，从图像到段落再到列表，所有元素都可以浮动

**浮动元素**
会以某种方式将浮动元素从文档的正常流中删除，不过它还是会影响布局
这种影响源自这样一个事实：一个元素浮动时，其他内容会“环绕”该元素；浮动元素周围的外边距不会合并
如果确实要浮动一个非替换元素，则必须为该元素声明一个width。否则，根据CSS规范，元素的宽度趋于0

**不浮动**
float: none可以防止元素浮动

**浮动的详细内幕**
浮动元素的包含块是其最近的块级祖先元素；浮动元素会生成一个块级框，而不论这个元素本身是什么

**控制浮动元素摆放的规则**
1. 浮动元素的左（或右）外边界不能超出其包含块的左（或右）内边界
2. 浮动元素的左（或右）外边界必须是源文档中之前出现的左浮动元素的有（左）外边界，除非后出现浮动元素的顶端在先出现浮动元素的底端下面（防止浮动元素彼此“覆盖”；定位很容易导致元素相互覆盖）
3. 左浮动元素的右外边界不会在其右边右浮动元素的左外边界的右边。一个右浮动元素的左外边界不会在其左边任何左浮动元素的右外边界左边（防止浮动元素相互重叠）
4. 一个浮动元素的顶端不能比其父元素的内顶端更高。如果一个浮动元素在两个合并外边距之间，放置这个浮动元素时就好像在两个元素之间有一个块级父元素
5. 浮动元素的顶端不能比之前浮动元素或块级元素的顶端更高
6. 如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高
7. 左（或右）浮动元素的左边（右边）有另一个浮动元素，前者的右外边界不能再其包含块的右（左）边界的右边（浮动元素不能超出其包含元素的边界，除非它太宽，本身都无法放下）
8. 浮动元素必须尽可能高地放置（受前7条规则的限制）
9. 左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远。位置越高，就会向右或向左浮动得越远

**实用行为**
浮动规则只处理了浮动元素和其父元素的左、右和上边界，而没有涉及下边界（浮动元素比父元素高）
注：有些浏览器会增加父元素的高度，使浮动元素能够包含在父元素中，即时这会导致父元素中出现大量多余空白
CSS2.1澄清了浮动元素行为的一个方面：浮动元素会延伸，从而包含其所有后代浮动元素
元素背景“滑到”浮动元素下面（浮动元素同时处于流内和流外）

**负外边距**
负外边距可能导致浮动元素移到其父元素外面（从数学上计算并没有违背规范）
CSS1和CSS2规范明确指出，用户代理不必重新显示已显示内容来适应文档中后来出现的内容

#### 浮动元素、内容与重叠2
CSS2.1有以下规则：
* 行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素“之上”显示
* 块框与一个浮动元素重叠时，其边框和背景在该浮动元素“之下”显示，而内容在浮动元素“之上”显示
注：重叠行为与源文档中的顺序无关
#### 清除
如果第一个元素可能放在一个浮动元素旁边，则会下推，直到出现在浮动元素的下面，而且后续内容都在其后面出现；这可以利用clear属性完成（应用与块级元素；大多数浏览器的默认行为都是为br元素生成行内框，所以clear不能应用于br，除非改变其display值！）
在CSS1和CSS2中，clear工作如下，它会增加元素的上外边距，使之最后落于浮动元素的下面，这实际上会忽略为清除元素顶端设置的外边距宽度
在CSS2.1中，引入了一个清除区域。清除区域是在元素外边距之上增加的额外间隔，不允许任何浮动元素进入这个范围。
大多数情况下无法知道一个元素周围多大范围内不允许有浮动元素。要确保一个清除元素的顶端与一个浮动元素的底端之间有一定空间，可以为浮动元素本身设置一个下外边距
### 定位
#### 基本概念
**定位的类型**
通过使用position属性，可以选择4种不同类型的定位，这会影响元素框生成的方式。
* static
  元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素会创建一个或多个行框，置于其父元素中
* relative
  元素框偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。
* absolute
  元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框
* fixed
  元素框的表现类似于将position设置为absolute，不过其包含块是视窗本身

**包含块**
对于浮动元素，其包含块定义为最近的块级祖先。对于定位，情况没有这么简单。CSS2.1定义了以下行为：
* “根元素”的包含块（也称初始包含块）由用户代理建立。在HTML中，根元素就是html元素，不过有些浏览器会使用body元素作为根元素。在大多数浏览器中，初始包含块是一个视窗大小的矩形
* 对于一个非根元素，如果其position值是relative或static，包含块则由最近的块级框、表单元格或行内祖先框的内容边界构成
* 对于一个非根元素，如果其position值是absolute，包含块设置为最近的position值不是satic的祖先元素（可以是任何类型）。这个过程如下：
    * 如果这个祖先是块级元素，包含块则设置为该元素的内边距边界；换句话说就是由边框界定的区域
    * 如果这个祖先是行内元素，包含块则设置为该祖先元素内容边界
    * 如果没有祖先，元素的包含块定义为初始包含块
注：元素可以定位到其包含块的外面；包含块实际上是定位上下文

**偏移属性**
三种定位机制（relative、absolute和fixed）使用了4个属性来描述定位元素各边相对于其包含块的偏移。这些属性描述了距离包含块最近边的偏移。（使用外边距边界完成偏移计算）正值会导致向内偏移，使边界朝着包含块的中心移动，而负值会导致向外偏移
偏移属性默认值为auto。对于auto没有定义行为；它会根据所用的定位类型改变
#### 宽度和高度
**设置宽度和高度**
尽管有时设置一个元素的宽度和高度很重要，但对于定位元素来说则不一定必要。例如如果使用top、right、bottom和left来描述元素4个边的放置位置，那么元素的高度和宽度将由这些偏移隐含确定；width和height的默认值都是auto

**限制宽度和高度**
可以使用CSS属性min-width和min-height max-width和max-height最小最大属性来限制元素宽度

**内容溢出与裁剪**
假设出于某种原因，一个元素固定为某个特定大小，但内容在元素中放不下。此时就可以利用overflow属性控制这种情况；默认值为visible，元素内容在元素框之外也可见。一般地，这会导致内容超出自己的元素框，但不会改变框的形状；如果overflow设置为scroll，元素的内容会在元素框边界处裁剪--在Web浏览器中，这可能意味着使用一个滚动条（或类似的东西）或者使用另外某种方法访问内容而不会改变元素本身的形状（即使元素有足够的空间显示所有内容，也应当显示滚动条--避免动态环境中滚动条出现或消失所带来的问题）；如果overflow被设置为hidden，元素的内容会会长元素框的边界处裁剪，不过不会提供滚动接口使用户访问超出剪裁区域的内容；auto允许用户代理来确定采用何种行为，不过都建议在必要时提供一个滚动机制

**内容剪裁**
如果一个绝对定位元素的内容溢出其内容框，而且overflow设置为要求剪裁该内容，通过使用属性clip可以改变剪裁区域的形状；默认值auto表示元素的内容不应剪裁。还可以相对于元素内容区定义一个裁剪形状。这不会改变内容区的形状，而只是改变将显示内容到的区域形状
clip中所有偏移都是距左上角的偏移（不允许有百分数，实际上不可能创建一个“中心”裁剪区，除非知道元素本身大小）
如果设置为auto，这相当于将裁剪边界设置为适当的内容边界
可以设置负长度值，这会使剪裁区域延伸到元素框之外；可以超越下边界和右边界，但不能超越上边界或左边界
注：当前浏览器中clip的实现方式并不一致（左上偏移；边偏移）

**元素可见性**
可以使用visibility控制整个元素的可见性
visibility: hidden，会将元素设置为“不可见”。处于不可见状态时，元素还是会影响文档的布局，就好像它还可见一样（display: none不仅元素不显示，还会从文档中删除，所有对文档布局没哟任何影响）
visibility: collapse值再CSS表显示使用，根据CSS2规范，如果用于非表元素，collapse与hidden含义相同
#### 绝对定位
定位元素不会流入其他元素的内容，反之亦然。这说明，绝对定位元素可能覆盖其他元素，或者被其他元素覆盖。
创作人员通常会选择一个元素作为绝对定位元素的包含块，将其position指定为relative而且没有偏移
要避免定位元素覆盖元素并能看到内容唯一的办法就是为定位元素设置一个背景，或者将其从段落中完全去除
注：元素绝对定位时，还会为其后代元素建立一个包含块
注：如果文档可滚动，定位元素会随着它滚动。只要绝对定位元素不是固定定位元素的后代

**绝对定位元素的放置和大小**
根据偏移属性可以确定元素宽高；如果同时指定元素宽高可能存在有些值错误，相应地必须将其忽略。到底哪一个值有错误，取决于很多因素，而且根据元素是替换元素还是非替换元素还会有所不同

**自动边偏移**
元素绝对定位时，如果除bottom外某个任意偏移属性设置为auto，会有一种特殊的行为
对于left：元素的左边界会相对于其包含块的左边界放置；对于top:定位元素的顶端要相对于其未定位前本来的顶端位置对齐
如果left和right设置为auto，也适用同样的基本规则。在这些情况下，定位元素的左（或右）边界与元素为定位时该边界原本的位置对齐（这种自动放置只在某些情况下可行，这些情况下通常对定位元素的其他尺寸没有什么限制）
注：CSS2.1（元素的）“静态位置”一词大致含义是：元素在正常流中原本的位置

**非替换元素的放置和大小**
一般地，元素的大小和位置取决于其包含块。各个属性（width、right、padding-left等）的值也会有一些影响，不过最主要的还是其包含块
注：如果一个绝对定位元素的大小在垂直方向上过度首先，将忽略bottom

**替换元素的放置和大小**
非替换元素和替换元素的定位规则大不相同。这是因为替换元素有固有的高度和宽度，因此其大小不会改变，除非创作人员有意显示地修改
确定替换元素位置和大小规则：
1. 如果width设置为auto，width的实际使用值由元素内容的固有宽度决定
2. 在从左向右读的语言中，如果left值为auto，要把auto替换为静态位置。在从右向左的语言中，则把right的auto值替换为静态位置
3. 如果left或right仍为auto，则将margin-left或margin-right的auto值替换为0
4. 如果此时margin-left和margin-right都还定义为auto，则把它们设置为相等的值，从而将元素在其包含块中居中
5. 在此之后，如果只剩下一个auto值，则将其修改为等于等式的余下部分
沿垂直轴的布局规则：
1. 如果height设置为auto，height的计算值由元素内容的固有高度确定
2. 如果top的值为auto，将其替换为替换元素的静态位置
3. 如果bottom的值为auto，将margin-top或margin-bottom的所有auto值替换为0
4. 如果此时margin-top和margin-bottom都还定义为auto，将其设置为相等的值，从而使元素在其包含块中居中
5. 在此之后如果，仅剩下一个auto值，则将其修改为等于等式中的余下部分

**z轴上的放置**
两个元素视图放在同一个位置上，如何控制哪个元素放在“上层”，引入属性z-index
有较高z-index值的元素比z-index值较低的元素离读者更近。这会导致有较高z-index值的元素覆盖其他元素，也称为叠放
一旦为一个元素指定了z-index值，该元素就会建立自己的局部叠放上下文。这意味着，元素的所有后代相对于该祖先元素都有其自己的叠放顺序
z-index默认值auto：当前叠放上下文中生成框的栈层次与其父框的层次相同。这个框不会建立新的叠放上下文。可以将z-index: auto 处理为z-index: 0
注：在CSS2.1中，叠放规则有所改变，要求元素绝对不会叠放在其叠放上下文的背景之下
注：由于用户代理的做法不同，所以z-index值为负时会导致不可预料的后果，所以使用要小心
#### 固定定位
固定定位与绝对定位很类似，只不过固定元素的包含块是视窗。
可以使用固定定位创建帧式界面；在屏幕上放置一个“永久性”元素
#### 相对定位
当元素相对定位时，它会从其正常位置移走，不过，原来所占的空间并不会因此消失
如果相对定位一个元素，它会立即为其所有子元素建立一个新的包含块。这个包含块对应于该元素原本所在的位置
注：如果遇到过度受限的相对定位，一个值会重置为另一个值的相反数。因此，bottom总是等于-top；在相对定位中，right总是等于-left（左右语言--右左语言相反）
## 表布局
在CSS2.1中，表本身就能够确定其他元素的元素大小
### 表格式化
组装表的基本方法和表中元素相互之间的关系成为表格式化

**表的视觉编排**
CSS对于表元素和内部元素有很分明的界限。在CSS中，内部表元素生成矩形框，这些框有内容、内边距和边框，但是没有外边距。因此，不能通过指定外边距来定义单元格间的间隔（总标题例外）
表的编排规则基础是“表格单元”，它们很大程度上是理论性构造，不能为它们设置样式，甚至不能通过文档对象模型来访问。这些构造只是用于描述如何组装表来设置样式。

**表的编排规则**
* 每个行框包含一行表格单元。（表的标题行框和脚注行框例外）
* 一个行组包含多少个行框，该汉族框就包含多少个表格单元
* 列框包含一列或多列表格单元
* 列组中包含多少个列框，该列组框中就包含多少个表格单元
* 尽管单元格可能跨多行或多列，不过CSS对此并没有做出定义，而是由文档语言来定义这种跨行或跨列
* 单元格框不能超出表或行组的最后一个行框。如果表结构可能造成这种情况，单元格则必须缩小，使之能放在包含它的表或行组中
注：CSS规范不建议（但是也不禁止）对表单元格和其他内部表元素定位
注：表格单元是矩形，不过不必都是相同大小。给定表格列中所有表格单元宽度相等，一个表格行中的所有表格单元则高度相等

#### 表显示值
在HTML中，很容易知道哪些元素属于表，因为像tr和td之类元素的处理已经内置在浏览器中。与此不同，在XML中则没有办法从根本上指导哪些元素可能是表的一部分。因此引入一组display值。
* table
  这个值指定一个元素定义一个块级表。（它定义了一个生成块框的矩形块）
* inline-table
  这个值指定一个元素定义了一个行内级表。（它定义了一个生成行内框的矩形块）
* table-row
  这个值指定一个元素是一个单元格的行
* table-row-group
  这个值指定一个元素是一个或多个行的行组
* table-header-group
  这个值与table-row-group非常相似，只是视觉格式化方面有所不同，标题行组总是在所有其他行和行组之前显示（总标题之后）
* table-footer-grou
  这个值与table-header-group很类似，不过脚注行组总是在所有其他行之后显示，如果最下面有页脚标题，要在该总标题之前显示
* table-colum 
  这个值声明元素描述了一个单元格的列（按CSS的术语来说，有这个display值的元素并不显示，就好像它的display值为none一样--为了帮助定义列中单元格的表示）
* table-column-group
  这个值声明一个元素是一个或多个列的组。
* table-cell
  这个值指定一个元素表示表中的单个单元格
* table-caption
  这个值定义一个表的总标题

**以行为主**
CSS将其表模型定义为“以行为主”。（显示声明行，列是从单元格行的布局推导出来）

**列**
单元格可能同时属于两个上下文（行和列）。在CSS中列和列组只能接受4种样式：border、background、width和visibility
这些属性应用于列上下文的特殊规则
* border
  只有当border-collapse属性值为collpase时才能为列和列组设置边框。在这种情况下，列和列组边框会参与设置个单元格边界边框样式的合并算法
* background
  只有当单元格及其行有透明背景时，列或列组的背景才可见
* width
  这个属性定义了列和列组的最小宽度。列（或列组）中单元格的内容可能要求列更宽
* visibility
  如果一个列或列组的visibility为collapse，则该列（或列组）中所有单元格都不显示。从合并列跨到其他列的单元格会被剪裁。另外，表的总宽度会减去已合并列的宽度。（如果对列或列组visibility声明为任何非collapse值，则会被忽略）

**匿名表对象**
标记语言中可能未包含足够的元素，CSS定义了一种机制，可以将“遗漏的”组件作为匿名对象插入
**对象插入规则**
1. 如果一个table-cell元素的父元素不是table-row元素，则会在该table-cell元素及其父元素之间插入一个匿名table-row对象。所插入的这个对象将包含该table-cell元素的所有连续兄弟
2. 如果一个table-row元素的父元素不是table、inline-table或table-row-group元素，则会在该table-row元素及其父元素之间插入一个匿名table元素。插入的这个对象将包含该table-row元素的所有连续兄弟
3. 如果一个table-column元素的父元素不是table、inline-table或table-column-group元素，则在该table-column元素及其父元素之间插入一个匿名table元素
4. 如果一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元，则会在该元素及其父元素之间插入一个匿名table元素
5. 如果一个table或inline-table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-row、table-caption元素，则在该table元素与其子元素之间插入一个匿名table-row对象。这个匿名对象将包含该子元素除上述元素的连续兄弟
6. 如果一个table-row-group、table-header-group或table-footer-group元素的子元素不是table-row元素，则在该元素及其子元素之间插入一个匿名table-row对象。这个匿名对象包含该子元素的所有本身非table-row对象的连续兄弟
7. 如果一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素间插入一个匿名table-cell对象。这个匿名对象包含该子元素的所有本身非table-cell元素的连续兄弟（扩展到匿名行内框）

**表层**
为了完成表的显示，CSS定义了6个不同的“层”，可以分别放表的不同方面
单元格-》行-》行组-》列-》列组-》表
基本来说，对应表各个方面的样式都在其各自的层上绘制（行背景会覆盖列背景）

**表标题**
CSS规范指出，表标题格式化为就好像它是直接放在边框之前（或之后）的一个块框，只有两个不同。
1. 表标题仍能从表继承值
2. 用户代理在考虑如何处理表前面的run-in元素时会忽略表标题框（如果一个run-in元素在表之前，它不会进入表的上标题，也不会进入表中，而是处理为好像其display值为block）
注：caption的宽度要基于table元素的内容宽度，这是caption的包含块
注：为表标题设置样式是一个很危险的事情
### 表单元格边框
CSS中实际上有两种截然不同的边框模型。分隔边框模型和合并边框模型（前者是默认模型，不过在CSS较早版本中，后者才是默认模型）
通过border-collapse在这两种模型中做出选择

**分隔单元格边框**
采用这种模型，表中每个单元格都与其他单元格分开一定距离，而且单元格的边框彼此不会合并
**边框间隔**
利用border-spacing属性可以使表单元格边框分隔一段距离（除非border-collapse值为separate，否则会忽略该属性）
如果提供两个长度值，则要求第一个值始终是水平间隔，第二个值始终是垂直间隔
注：在分隔边框模型中，不能我行、行组、列和列组设置边框。如果为这些元素声明了边框属性，都会被CSS兼容的用户代理所忽略

**处理空单元格**
没有内容的单元格
内容不仅包括文本、图像、表单元素等等，还包括不可分空间实体（&nbsp;）和出CR（回车）、LF（换行）、tab和空格符以外的所有其他空白符
如果一行中的所有单元格都为空，而且empty-cells值都是hide，则整行将处理为好像这个行元素设置为display: none

**合并单元格边框**
合并单元格边框规则：
* display值为table或inline-table的元素不能有任何内边距，不过它们可以由外边距
* 边框可以应用到单元格、行、行组、列和列组
* 单元格边框之间绝对不会有任何间隙。如果边框相邻，就会相互合并，单元格边框合并时，”最有意思的“边框会胜出
* 一旦合并，单元格之间的边框会在单元格间的假想表格线上居中
**合并边框布局**
在这个模型中，宽度只包含表边框的一般。另一半在此距离之外，落在外边距中
在开始建立一个合并边框表的布局时，用户代理会为表本身计算一个初始的左右边框。（表中第一行第一个单元格的做边框的一半，第一行中最后一个单元格的有边框的一半）
如果边框的宽度是一个奇数，用户代理必须决定如何将边框在表格线上居中（移动该边框，使之稍稍偏离中心；宽度向上或向下调整为一个偶数；采用其他看上去合理的做法）
**边框合并**
* 如果某个合并边框的border-style为hidden，它会优先于所有其他合并边框。这个位置上的所有边框都隐藏
* 如果某个合并边框的border-style为none，它的优先级最低
* 如果至少有一个合并边框的borderstyle值不是none，而且所有合并边框的border-style值都不是hidden，则窄边框不敌更宽的边框。如果多个合并边框拥有相同的宽度，则会考虑边框样式，并采用以下顺序（从最优先到最不优先）：double、solid、dashed、dotted、ridge、outset、groove、inset
* 如果合并边框的样式和宽度都一样，但是颜色不同弄，则按下表顺序使用元素的颜色（从最优先到最不优先）：cell、row、row group、column、column group、table。如果元素类型相同，则颜色取最上最左边框的颜色
### 表大小
确定表的宽度，有两种不同的办法：固定宽度布局和自动宽度布局。不论使用何种宽度算法，高度都会自动计算
#### 宽度
创作人员可以使用属性table-layout来选择采用哪种方法计算表的宽度
这两种布局之间最显著的差异是速度。使用固定宽度表布局时，相对于自动宽度模型，用户代理可以更快地计算出表的布局

**固定布局**
固定布局之所以块，主要原因是布局不依赖于表单元格的内容。其布局是根据该表以及表中列和单元格的width决定的
1. width属性值不是auto的所有列元素会根据width值设置该列宽度
2. 如果一个列的宽度为auto，不过，表首行中位于该列的单元格width不是auto，则genuine该单元格宽度设置此列宽度。如果单元格跨多列，则宽度再这些列上平均分配
3. 如果列宽度仍为auto，会自动确定其大小，使其宽度尽可能相等
此时，表的宽度设置为表的width或列宽度之和（取其中较大者）。如果表宽度大于其列宽综合，将二者之差除以列数，在把得到的这个宽度增加到每一列上

**自动布局**
1. 对于一列中的各个单元格，计算最小和最大单元格宽度
    * 确定显示内容所需的最小宽度。如果单元格的width值大于最小可能宽度，则把最小单元格宽度设置为该width。如果单元格的width值为auto，最小单元格宽度设置为最小内容宽度
    * 对于最大宽度，要确定完全显示内容而且包括换行符所需的宽度。这个值就是最大单元格宽度
2. 对于每一列，计算最小和最大列宽
    * 列的最小宽度由该列中所有单元格的最小单元格宽度的最大值确定。如果该列指定的width值大于列中所有最小单元格宽度，最小列宽则设置为这个width值
    * 取该列这种所有单元格的最大单元格宽度的最大值。如果已经指定了一个width，而且大于该列中所有最大单元格宽度，最大列宽设置为该width值
3. 如果一个单元格跨多列，最小列宽之和必须等于这个跨列单元格的最小单元格宽度。类似地，最大列宽之和必须等于跨列单元格的最大宽度。如果列宽之和与单元格宽度有差距，用户代理会把这个差距在所跨列上平均分配
用户代理确定各列可能多宽或多窄后，得到真正的表的宽度：
1. 如果表的计算宽度值不是auto，将这个计算表宽度值与所有列宽再加上所有边框和单元格间隔之和相比较（设置为百分数宽度的列此时计算具体宽度）。取其大，前者大，所有列宽增加一个相等的量，填充表
2. 如果表的计算宽度为auto，通过将列宽、边框和单元格间隔相加来确定表的最终宽度。

**高度**
可以使用height指定表的高度，CSS2.1规范草案指出，将height看做边框的最小高度。用户代理可以扩展或收缩表中的表行来适应表的高度，也可以在表框中留白或采取其他完全不同的做法
如果表的高度是auto，其高度则是表中所有行高再加上所有边框和单元格间隔的总和。要确定各行的高度，用户代理需要完成一个与确定列宽类似的过程
注：表的高度计算在很大程度上留给用户代理来决定。历史证明，各用户代理很可能有不同的做法，所以要尽可能避免设置高度

**对齐**
垂直对齐很容易影响行高
使用text-align处理水平对齐
使用vertical-align属性实现垂直对齐（很多值与垂直对齐行内内容一样）
* top
  单元格内容顶端与其行顶端对齐；对于跨行单元格，单元格内容的顶端与其所跨的第一行顶端对齐
* bottom
  单元格内容底端与其行底端对齐；对于跨行单元格，单元格内容的底端与其所跨的最后一行底端对齐
* middle
  单元格内容的中间与其行中间对齐；对于跨行单元格，单元格内容的中间与其所跨行的中间对齐
* baseline
  单元格的基线与其行基线对齐；对于跨行单元格，该单元格的基线与所跨第一行的基线对齐
自动增加单元格本身内边距完成对齐
行的基线由该行所有单元格中最低初始单元格基线定义
其他vertical-align值会被忽略
对一行单元格内容对齐的过程：
1. 如果某些单元格是基线对齐，则确定该行的基线，并放置这些基线对齐单元格内容
2. 放置所有顶端对齐单元格的内容。行现在有了一个临时高度，由已经放置了内容的单元格的最低单元格底端确定
3. 如果剩下的单元格是居中对齐或底端对齐，而且内容高度大于临时行高，行高则增加到可以包含其中的最高的单元格
4. 放置所有余下单元格的内容。如果单元格内容的高度比行高小，则增加单元格的内边距，使之适应行高
## 列表与生成内容
列表中的项就是块框，不过比其平常稍微多了一点，多出的部分不属于文档布局，主要由用户代理计算并格式化
CSS2引入了一些特性，可以描述这种列表项编号，允许创作人员定义自己的计数模式和格式，可以将这些计数器与任何元素关联（还有可能向文档中插入其他类型的内容，包括文本串、属性值，甚至外部资源）
### 列表
从某种意义上讲，不是描述性文本的任何内容都可以认为是列表

**列表类型**
可以使用属性list-style-type修改列表项的标志类型
disc--实心圆 circle--空心圆 square--方块 decimal--数字 decimal-leading-zero--补零数字 upper-latin upper-alpha--大写字母 lower-alpha lower-latin--小写字母 upper-roman--大写罗马 lowe-roman--小写罗马 lower-greek--小写希腊 armenian--亚美尼亚 georgian--乔治 none--不使用标志（CSS2.1）
用户代理会把它无法识别的值处理为decimal
CSS无法区分有序列表项和无序列表项
none会导致用户代理在原本放标志的位置上不显示任何内容，不过它不会中断有序列表中的计数

**列表项图像**
可以使用list-style-image对各标志使用一个图像
通常可以提供一个作为“后路”的标志类型以应付意外情况（图像未能加载、被破坏或者是某种用户代理无法显示的格式）

**列表标志位置**
可以使用list-style-position属性来确定标志出现在列表项内容之外还是内容内部
默认值为outside

**简写列表样式**
可以将上述三个列表样式属性合并为简写属性list-style（顺序任意）
#### 列表布局
值list-item确实定义为生成块框
标志和列表内容之间的距离在CSS中未定义
如果标志放在列表项内容之外，它们不会影响其他元素的布局，也不会影响列表项本身的布局。标志的行为就像是标志相对于列表项内容绝对定位一样；如果标志在列表项内容内部，则相当于放在内容开始处到的一个行内元素
列表元素也是一个块框，大多数浏览器会通过设置列表元素的内边距或外边距来完成列表项的缩进
### 生成内容
生成内容指由浏览器创建的内容，而不是由标志或内容来表示

**插入生成内容**
可以使用:before和:after伪元素向文档中插入生成内容，伪元素根据content属性生成内容
生成内容和元素内容之间没有空格；生成内容放在元素框内部
在CSS2.1中，除了列表标志，无法把生成内容放在元素框之外
CSS2和CSS21明确禁止浮动或定位:before和:after内容，还禁止使用列表样式属性以及表属性。还有以下限制：
* 如果:before或:after选择器的主题是块级元素，则display属性只接受值none、inline、block和marker。其他值都处理为block
* 如果:before或:after选择器主题是一个行内元素，属性display只能接受值none和inline。所有其他值都处理为Inline
生成内容由与之关联的元素继承值
#### 指定内容
可以使用content属性来描述生成的内容
串值会原样显示，即使其中包含某种标记也不例外；要使用换行需要使用串\A（Unicode换行符）

**插入属性值**
可以通过attr()取一个元素的属性值；如果一个属性不存在，会在相应的位置插入一个空串
注：CSS2.x定义属性引用的返回值是未解析的串（如果一个属性包含标记或字符实体，会原样显示）

**生成引号**
CSS2.x提供了一种有效的方式来管理引号及其嵌套行为
值open-quote和close-quote用于插入何时的引号符号。它们使用qoutes值来确定如何工作
利用quotes可以定义任意多层嵌套引用模式；如果引号的嵌套层数大于已定义的引号对数，最后一对引号将重用于更深层次的嵌套
CSS2.1规范指出：引用深度不依赖于源文档或格式化结构的嵌套
no-open-quote关键字，其效果与no-close-quote对称。这个关键字会让引用嵌套层次增1，但不生成符号
#### 计数器
有序列表中的列表标志就是计数器。

**重置和递增**
可以使用counter-reset设置计数器起点；标识符 数字；默认数字为0
可以使用counter-increment指示元素将计数器递增；标识符 数字；默认数字为1

**使用计数器**
要显示计数器，还需要结合使用content属性和一个与计数器有关的值
任何元素都可以利用计数器；可以通过counter()取得计数器值
计数器由同一个元素递增和使用时，递增发生在计数器显示之前；如果计数器在同一个元素宏重置和显示，重置也在计数器显示之前发生
在计数器标识符后面增加一个list-style-type关键字，用逗号分隔改变计数器样式
注：display为none的元素不会递增计数器；visibility为hidden的元素会递增计数器

**计数器和作用域**
每层嵌套都会为给定计数器创建一个新的作用域
可以使用counters()将一个新计数器追加到老计数器上

## 用户界面样式
CSS的绝大部分都是关于文档的样式，不过它还提供了很多有用的界面样式工具，而不仅仅面向文档
### 系统字体和颜色
自己的文档尽可能地模仿用户的计算环境

**系统字体**
CSS2定义了6个系统字体关键字。分别描述如下：
* caption
  由标题控件使用的字体样式，如按钮和下拉控件
* icon
  操作系统图标标签所用的字体样式，如硬盘驱动器、文件夹和文件图标
* menu
  下拉菜单和菜单列表中文本使用的字体样式
* message-box
  对话框中文本使用的字体样式
* small-cpation
  由标题小控件的标签使用的字体样式
* status-bar
  窗口状态条中文本使用的字体样式
这些值只能用于font属性，它们本身就是简写形式
#### 系统颜色
CSS2定义了28个系统颜色关键字
* ActiveBorder（活动窗口的外边框）
* ActiveCaption（活动窗口标题背景色）
* AppWorkspace（支持多个文档的应用中使用的背景色）
* Background（桌面背景色）
* ButtonFace（三维按钮“面”上使用的颜色）
* ButtonHighlight（三维显示元素背离虚拟光源的边沿上的亮色）
* ButtonShadow（三维显示元素的阴影色）
* ButtonText（“按下”按钮上文本的颜色）
* CaptionText（标题、大小框中的文本以及滚动箭头框中符号的颜色）
* GrayText（置灰--禁用文本）
* Hightlight（控件中选中项的颜色）
* HightlightText（控件中选中项的文本颜色）
* InactiveBorder（应用于不活动窗口的外边框的颜色）
* InactiveCaption（不活动窗口的标题的背景色）
* InactiveCaptionText（不活动标题中的文本颜色）
* InfoBackground（工具提示中的背景色）
* InfoText（工具提示中的文本颜色）
* Menu（菜单背景的颜色）
* MenuText（菜单中的文本颜色）
* Scrollbar（滚动条的“灰色区域”）
* ThreeDDarkShadow（与三维显示元的深阴影颜色相同）
* ThreeDFace（与三维显示元素的表面颜色相同）
* ThreeDHighlight（三维显示元素上的亮色）
* ThreeDlightShadow（三维显示元素上的浅色）
* ThreeDShadow（三维显示元素上的深阴影）
* Window（窗口的背景的颜色）
* WindowFrame（应用于窗口的框架的颜色）
* WindowText（窗口中的文本颜色）
CSS2将系统颜色关键字定义为不区分大小写；系统颜色关键字本质上是含糊的，不同的用户代理可能以不同方式解释这些关键字
### 光标
####改变光标
CSS2允许改变光标图标，利用cursor属性完成；默认值auto只表示用户代理应当确定最合适当前上下文的光标图标。这与default不同，后者要求图标是操作系统的默认光标

**指示和选择光标**
值pointer会把光标图标改为与移动超链接时的光标相同
选择光标只要用户能选择文本，就会出现这个图标
指示交互性的另一种方法是使用值crosshair，该值会把光标图标变为一个十字符号。十字符号通常用于屏幕捕捉程序

**移动光标**
在很多情况下，move值会得到与crosshair类似的结果。创作人员需要指示一个屏幕元素可以移动时就会使用move（通常显示为一个加粗的十字线，线的两端分别有箭头；也可以显示为一个“拳头”）
光标放在窗口右边界出现e-resize光标；左下角sw-resize

**等待和前进**
wait和progress都指示程序正在忙。wait表示用户要等待直到程序不忙为止；progress（CSS2.1）指示用户可以继续与程序交互，尽管它很忙

**提供帮助**
有时创作人员希望指示用户可以得到某种形式的帮助，此时就可以使用值help（还可以指示一个元素由“额外”信息）

**图形光标**
可以通过URL值来指定定制光标；在cursor语法定义中，URL必须跟有一个逗号和某个通用关键字

### 轮廓
轮廓类似于边框，但是轮廓不参与到文档流中，并且可能不是矩形
利用轮廓，用户代理可以“合并”部分轮廓，创建一个连续但非矩形的形状
轮廓与边框不是同一个东西，所以可以在同一个元素上共存
CSS2规范指出：“轮廓可以画在边框边界的外面。”
一般认为轮廓是用户界面样式的一部分，这是因为它们最常用于指示当前焦点
#### 设置轮廓样式
可以使用outline-style设置轮廓样式（hidden不是一个合法的轮廓样式）；只能为outline-style指定一个关键字
#### 轮廓宽度
可以使用outline-width为轮廓设置宽度，同样只能指定一个关键字
#### 设置轮廓颜色
可以使用outline-color伪轮廓设置颜色，invert为默认值，反色轮廓意味着要对轮廓所在像素完成反色转换
#### 汇总
轮廓有一个简写属性outline，允许一次完成轮廓样式、宽度和颜色的设置
轮廓画在元素框余下部分之上。CSS2中轮廓不会覆盖其元素框的可见部分，而只能覆盖外边距（透明外边距）
## 非屏幕媒体
可以将文档设计为既能通过视觉途径表现，又能通过非视觉途径表现
### 设计特定于媒体的样式表
利用HTML和CSS中定义的机制，可以将样式表限制为仅用于某种特定媒体（通过media属性）
在样式表本身，还可以使用@import规则限制媒体；如果没有为样式表增加媒体信息，它会应用于所有媒体
CSS2还定义了@media块的语法，允许在同一个样式表中未多个媒体定义样式
### 分页媒体
在CSS术语中，分页媒体是把文档表示处理为一系列离散“页面”的媒体；这与屏幕媒体有所不同，屏幕媒体是一种连续型媒体：文档表示为一个可滚动的“页面”；分页媒体中更难使用多列布局
#### 打印样式
打印样式也会应用于”打印预览“模式的文档显示

**屏幕与打印的区别“
* 物理差异
* 字体选择（屏幕sans-serif字体；打印媒体serif字体更可读）
* 字体大小（Web设计一般不使用点；打印设计可以使用点，甚至厘米或派卡）
* 大多数打印输出中没有背景

**定义页面大小**
CSS定义了描述页面组件的页框；页框由两个区组成：
* 页面区
  这是页面中放内容的部分
* 外边距区
  这是围绕页面区的部分
可以使用@page规则来设置页框大小和外边距大小。在CSS2.1中，创作人员只能设置外边距大小

**选择页面类型**
CSS2允许通过命名@page规则来创建不同的页面类型；可以通过page属性向不同的元素指定命名页面类型（CSS2.1已经去除）
可以通过;first伪类向文档中的第一个页面应用特殊样式；此外还有:left和:right可以对左页和右页分别设置样式

**分页**
可以使用page-break-before和page-break-after影响分页
默认值auto只是说明不要求在元素之前或之后分页（与正常打印输出相同）；always值导致在设置样式的元素之前（或之后）放一个分页符；值left和right的做法与always相同，只不过它们更进一步定义了继续打印哪种类型的页面（left如果是装订打印输出，出现在书脊左边；如果双面打印，这意味着在一张纸的“背面”打印）；avoid会让用户代理尽量避免在一个元素之前或之后放置分页符（只是avoid而不是never。无法绝对保证一个给定元素之前或之后不插入分页符）
使用page-break-inside属性可以请求用户代理尽量避免在一个元素内部放置分页符

**Orphans和windows**
orphans和windows可以对分页提供更精细的控制
值windows定义了放在页面顶部的元素在不导致前面增加分页符的前提下所包含的最小行框数
orphans定义了不会导致元素前增加分页符的前提下可以出现在页面底部的最小行框数

**分页行为**
实际上只有两个通用位置上允许有分页符。
两个块级框间。分页符之前元素margin-bottom重置为0，分页符之后的元素margin-top值重置为0
有两个规则允许在两个元素框之间放置分页符：
* 第一个元素的page-break-after值或第二个元素的page-break-before值是always、left或right。不论其他元素的值是什么（甚至可能是avoid），都必须在元素间放置分页符（这是强制分页符）
* 第一个元素page-break-after值为auto，第二个元素的page-break-before值也是auto，而且它们没有一个page-break-inside值不为avoid的共同祖先
第二个允许放分页符的通用位置是一个块级框中的两个行框之内。这也由两个规则控制：
* 只有当元素开始与分页符之间行框之间数小于该元素的orphans值时，才可能在两个行框之间出现分页符。类似地，只有当分页符之后行框与元素结束处的行框数小于windows值时，才可能在两个行框之间插入分页符
* 如果元素的page-break-inside值不是avoid，可能在行框之间放分页符
CSS“最佳”分页行为：
* 尽可能少分页
* 让所有不是以强制分页符结尾的页面有相同的高度
* 避免在有边框的块内部分页
* 避免在表内部分页
* 避免在浮动元素内部分页

**重复元素**
在CSS2中可以使用固定定位元素指定页头

**页面外的元素**
关于如何处理超出页框的内容，有两个非常重要
* 内容应该能稍稍超出页框
* 用户代理要注意不能只是为了满足定位信息而生成太多空页面
* 用户代理不能只是为了避免显示某些元素而把元素定位到奇怪的位置
* 放在页框之外的内容也能以多种方式表现

#### 投影样式
**建立幻灯片**
可以使用分页属性把一个文档分成一系列幻灯片

**定位元素**
在定位元素时，其初始包含块就是元素所在页框；类似于打印媒体，固定元素会出现在幻灯片的每一个页框中

**关于投影的考虑**
创建投影样式表示提前考虑一个特定的分辨率是合理的；如果采用对比强烈的颜色，投影文档对观众来说往往更可读；与正常的Web设计（以及其他方面）相比，投影更不能保证颜色的真实性

## 声音样式
CSS2.1废弃了媒体类型aural以及与之相关的所有属性
### 语音
使用属性speak确定一个给定元素的内容是否要以声音表现
默认值normal指示应该将一个元素的内容读出；如果一个元素及其后代都不能用声音表现，应当使用display: none；spell-out，这通常与缩略语或应当读出的其他内容结合使用
### 标点符号和数字
可以使用speak-punctuation影响标点符号的表现
默认值none，标点符号用声音表现时会作为适当长度的停顿，不过CSS并没有定义停顿多长（停顿长度往往取决于具体语言）；值code会把标点符号具体读出
可以使用speck-numeral影响数字的表现
默认值continuous表示数字会被读作一个完整的数；值digits会逐个读出数字（数字表现也依赖不同的语言，没有具体定义）
### 表标题的声音表现
在表的声音表现中，可能很容易失去控制，不知道单元格数据到底是什么意思，CSS2引入了speak-header
默认地，用户代理在遇到单元格时只会将表标题的内容表现一次；always只要所表现的单元格与标题相关，就总会表现该表标题信息
### 语速
CSS中speech-rate属性，这个属性用于设置怎样的语速表现内容
<number>指定按每分钟单词数指定语速；x-slow相当于每分钟80词 slow相当于每分钟120词；medium相当于每分钟80~120词；fast相当于每分钟300词 x-fast相当于每分钟500词；faster将当前语速提高每分钟40词 slower将当前语速降低每分钟40词
CSS没有定义具体如何改变语速。用户代理可以拉长每一个词，延长词之间的停顿，或者二者兼而有之
### 音量
可以使用volume控制用户代理产生的音量
<number>提供音量的数值表示。（0最小音量与静音不同；100对应最大音量）；<percentage>计算为继承值的一个百分数；silent静音，不产生声音；x-soft对应0；soft对应25；medium对应50；loud对应75；x-loud对应100
voulume定义的是平均音量，而不是所产生的每个声音的确切音量
### 指定声音
类似于font-family，CSS定义了一个名为voice-family的属性；CSS2.x没有定义通用系列值
#### 改变声音
**改变音高**
每个声音系列都有自己的默认音高，CSS允许创作人员使用属性pitch来改变音高；可以使用pitch-range来影响音高的变化范围，pitch-range的目的是加大或减少给定声音的变形，默认值为50

**重音与音色**
stress属性有助于创作人员减弱或加强语言的重音模式
默认值为50，取值取决于具体语言，同一个值可能会得到不同的重音级别和模式。CSS没有定义这种差别
richness在许多方面stress类似；richness值越高，就越“明亮”，它的“含义”就越丰富。值较低，声音就更轻柔，“更流畅”（引自CSS2规范）；默认值50
### 停顿和指示
#### 停顿
从某种意义上说，停顿就相当于声音领域的外边距（停顿和外边距都用于将元素与周围内容分开）
在CSS中，可以使用pause-before、pause-after和pause来向文档中插入停顿
pause-before和pause-after默认值为0；采用<time>值格式，可以用秒数或毫秒数来表示停顿长度；百分数要相对于speech-rate的隐含度量值来计算--每个词多少秒乘以百分数
pause是简写属性，如果只提供了一个值，它会同时作为元素之前和之后的停顿值
#### 提示
提示在声音领域相当于边框，有3个提示属性：cue-before、cue-after和cue
通过提供一个声音资源的URI，用户代理要加载该资源，并在元素前（或后）播放这个声音
#### 停顿、提示和生成内容
停顿和提示都在生成内容“之外”播放
CSS没有指示提顿在提示“之外”还是提示在停顿“之外”
#### 背景声音
在声音媒体中，背景是指读出元素的同时播放一个声音，play-during
repeat 一个声音在读元素期间一直重复，类似于background-repeat
mix 当子元素背景声音与父元素背景声音重叠时
none会去掉所有声音，包括可能属于祖先元素的声音
#### 声音定位
CSS2.x定义了两个属性来完成声音定位
azimuth 定义了发生源在水平面上的角度；leftwrds从当前azimuth角度值减去20deg，rightwards是向当前值增加20deg
elevation定义了声音在垂直面上的位置
higher和lower分别将当前俯仰角增加或减少10度

**结合azimuth和elevation的值，它们定义了以用户为中心的一个假想球体中的一个点