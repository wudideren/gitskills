# <center>高效并发</center>
## Java内存模型与线程
  并发处理的广泛应用使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机能力的最有力武器
  * Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力
  * 摩尔定律则用于描述处理器晶管与运行效率之间的发展关系
    注： 这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程
### 概述
  **多任务处理**
  这是一项“压榨”处理器的运算能力的手段
  计算机的运算速度与它的存储和通信子系统的差距过大

  **一个服务端同时对多个客户端提供服务（并发应用场景）**
  衡量一个服务性能的高低好坏，每秒事务处理数是最重要的指标之一
  TPS：代表一秒内服务端平均能响应的请求总数
  TPS与程序的并发能力关系密切
  对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然越高；反之，线程间频繁阻塞甚至死锁，将会大大降低程序并发能力

  Java语言和虚拟机提供了很多工具，把并发编程门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员尽处理可能多的线程并发细节，使得程序员在编写代码时能更加关注业务逻辑，而不是花费大部分时间去关注此服务会同时被多少人调用、如何协调硬件资源
### 硬件的效率与一致性
  绝大多数运算任务不可能只靠处理器“计算”完成，处理器至少要与内存交互，这个I/O操作很难消除（无法依靠寄存器完成所有运算任务）
  计算机存储设备与处理器的运算速度有几个数量级差距（现代计算机系统需要加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器间的缓冲：将运算需要使用的数据复制到缓存中，让运算快速进行，当运算结束后再从缓存同步到内存，这样处理器无须等待缓慢的内存读写）

  基于高速缓存的存储交互引入了一个新的问题：缓存一致性
  在多核处理器系统中，每个处理器都有自己的高速缓存，而它们共享同一主内存，当多个处理器的运算任务都设计同一块主内存区域时，可能导致各自缓存数据不一致
  解决一致性问题，各个处理器访问缓存时需要遵循一些协议，在读写时根据协议进行操作
  缓存读写协议：MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol
  内存模型：可以理解为在特定的操作协议下，对特定内存或高速缓存进行读写访问的过程抽象
  ![处理器、高速缓存、主内存交互关系](D:\local\notes\images\cache-coherence.bmp)
  注：为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算后将乱序执行结果重组，保证该结果与顺序执行结果一致，但不保证程序中各个语句计算的先后顺序与输入代码中顺序一致（Java虚拟机的JIT中也有类似的指令重排序优化）
### Java内存模型
  Java内存模型，在JDK1.2建立起来并在JDK1.5中完备
  Java虚拟机试图屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果
  注：主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异导致程序在一套平台上并发完全正确，而在另外一套平台上并发访问经常出错
#### 主内存与工作内存
  Java内存模型的主要目标：定义程序中各种变量（不包括局部变量和方法参数-线程私有；引用私有但是指向的对象共享）的访问规则（在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节）
  注：为了获得较好的执行效能，Java内存模型没有限制执行引擎使用处理器特定的寄存器或缓存来和主内存进行交互，也没有限制JIT进行调整代码执行顺序这类优化措施

  **Java内存模型**
  * Java内存模型规定了所有变量都存储在主内存中（虚拟机内存的一部分，并不是物理硬件主内存）
  * 每条线程都有自己的工作内存（可与处理器高速缓存类比）
  * 线程的工作内存中保存了被该线程使用的变量的主内存副本拷贝（不会拷贝整个对象）
  * 线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量
  * 不同线程之间无法直接访问对方工作内存中的变量
  * 线程间变量值的传递均需要通过主内存完成
    ![线程、主内存、工作内存交互关系](D:\local\notes\images\JMM.bmp)
    主内存：堆中实例数据部分
    工作内存：栈部分区域
    注：堆中除了实例数据，还保存了对象其他信息，对于HotSpot虚拟机来将，有Mark Word（存储对象哈希码、GC标志、GC年龄、同步锁等信息）、Kclass Point（指向存储类型与数据的指针）以及一些用于字节对齐补白的填充数据（如果实例数据刚好满足8字节对齐的话，则可以不存在补白）
    注：程序运行时主要访问读写的是工作内存
    注：从更低层次上说，主内存直接对应物理硬件内存，为了获取更好地运行速度，虚拟机（甚至硬件系统本身的优化措施）可能会让工作内存有限存储于寄存器和高速缓存中
#### 内存间交互操作
  主内存与工作内存间的具体交互协议（一个变量如何从主内存拷贝到工作内存、如何从工作内存同步会主内存之类的实现细节），Java内存模型定义了8中操作完成（虚拟机试下时必须保证下面的每一种操作都是原子的、不可再分的）
  1. lock（锁定）：作用于主内存变量，它把一个变量标识为一条线程独占状态
  2. unlock（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
  3. read（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存，以便随后的load动作使用
  4. load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
  5. use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时会执行这个操作
  6. assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
  7. store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存，以便随后的write操作使用
  8. write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

    注：Java内存模型要求read load和store write必须按顺序执行，而没有保证连续执行（两者之间可以插入其他指令）

  Java内存模型规定上述操作必须满足一下规则
  * 不允许read和load、store和write操作之一单独出现
  * 不允许一个线程丢弃它的最近的assign操作--即变量在工作内存中改变之后必须同步会主内存
  * 不允许一个线程无原因（没发生任何assign操作）把数据从线程工作内存同步会主内存
  * 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量--对一个变量实施use、store操作前必须先执行过了assign和load操作
  * 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次lock后，只有执行相同次数的unlock操作，变量才会被解锁
  * 如果对一个变量执行lock操作，那将会情况工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign擦欧洲哦初始化变量的值
  * 如果一个变量事先没有被lock操作锁定，就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量
  * 对一个变量执行unlock操作前，必须先把此变量同步会主内存中（执行store、write操作）
#### 对于volatile型变量的特殊规则
  关键字volatile：Java虚拟机提供的最轻量级的同步机制
  volatile在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存着不一致的情况，但是由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题）
  Java里的运算并非原子操作，导致volatile变量的运算在并发下一样不安全

  **volatile变量特性**
  保证此变量对所有线程的可见性--可见性指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的（普通变量需要回写主内存后才可见）
  注：volatile变量只能保证可见性--可以控制并发，在不符合以下两条规则的运算场景中，仍然要通过加锁（使用sychronized或java.until.concurrent中的原子类）来保证原子性
  1. 运算结果不依赖变量的当前值，或者能够确保只有单一线程修改变量值
  2. ***变量不需要与其他的状态变量共同参与不变约束***

  禁止指令重排序优化
  Java内存模型描述的“线程内表现为串行的语义”--一个线程的方法执过程中无法感知到变量赋值操作顺序与程序代码中执行顺序不一致
  指令重排序会干扰程序并发执行--线程A执行完某些操作设置标志位控制线程B执行，这时需要将标志声明为volatile，否则可能由于指令重排序导致操作未完成线程B就执行了
  volatile变量的赋值操作增加了一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前）

  volatile同步机制性能优于锁（使用synchronize关键字或java.util.concurrent包里的锁），但是由于虚拟机对锁实行的许多消除和优化，很难量化认为volatile比synchronized快多少
  volatile变量读操作性能消耗与普通变量几乎没差别，但写操作要慢一些，因为它需要在本地代码中插入许多内存屏障指令确保处理器不发生乱序
  大多数场景下volatile开销比锁低

  Java内存模型对volatile变量定义的特殊规则
  假设T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：
  * 只有当线程T对变量V执行的前一个动作是load时，线程T才能对变量V执行use动作；并且只有当线程T对变量V执行的后一个动作是use时，线程T才能对变量V执行load动作（线程T对变量V的use、load、read必须连续一起出现--每次使用V时必须先从主内存刷新最新的值，用于保证看见其他线程对变量V所做的修改后的值）
  * 只有当线程T对变量执行的前一个动作是assign时，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store时，线程T才能对变量V执行assign动作（assing、store、write必须连续一起出现--保证其他线程可以看到自己对变量V做的修改）
  * 动作A-线程T对变量V实施use或assign动作 动作F-和动作A关联的load或store动作  动作P-和动作F关联的read和write动作；动作B-线程T对变量W实施use或assign动作 动作G-和动作B关联的load或store动作  动作Q-和动作G关联的read和write动作；如果A优先于B，那么P优先于Q（用于保证被volatile修饰的变量不会被指令重排序优化，保证代码执行顺序与程序执行顺序相同）
    注：volatile屏蔽指令重排序语义在JDK1.5被完全修复
#### 对于long和duoble型变量的特殊规则
  Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性（这个就是long和double的非原子性协定）
  注：如果多个线程共享一个并未声明为volatile的long和double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个数量”的数值（很罕见-目前商用虚拟机中不会出现）
  注：Java内存模型允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性操作，而且“强烈建议”虚拟机这样实现
#### 原子性、可见性与有序性
  Java内存模型是围绕在并发过程如何处理原子性、可见性和有序性
  * 原子性
      * 由Java内存模型来直接保证原子性操作操作包括read、load、assign、use、store和write,我们大致可以认为基本数据类型的访问读写是原子性的（例外就是long和double的非原子协定）
      * 如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求（虚拟机未把lock和unlock操作直接开放给用户使用，但提供了更高层次的字节码指令monitorenter和monitorexit来隐式使用这两个操作--这两个字节码指令放映到Java代码中就是同步块synchronized关键字，因此在synchronized之间的操作具备原子性）
  * 可见性
      * 可见性指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
      * Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性
      * 除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final--同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”；final关键字的可见性指：被fianl修饰的字段在构造器中一旦从初始化完成，且没有吧“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见fianl字段的值
  * 有序性
      * Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无须的。
      * 前半句指“线程内表现为串行的语义”，后半句指“指令重排序”现象和“工作内存与主内存同步延迟现象”
      * Java语言提供了volatile和synchronized两个关键字保证线程间操作有序性
      * volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行进入
#### 先行发生原则
  先行发生原则：它是判断数据是否存在竞争、线程是否安全的主要依据。通过这个原则可以用几条规则解决并发环境下两个操作间是否可能存在什么冲突的所有问题
  先行发生是Java内存模型中定义的两项操作间的偏序关系--如果操作A先行发生于操作B，即在操作B发生前，操作A产生的影响能被操作B观察到（影响包括修改了内存中共享变量的值、发送了消息、调用了方法等）

  **Java内存模型下的“天然的”先行发生关系**
  这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用
  如果两个操作的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们随意地进行重排序
  * 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序（还要考虑分支、循环等结构）
  * 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作（同一个锁，“后面”指时间上）
  * volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作（时间上）
  * 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
  * 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测（检测线程终止--Thread.join()方法结束、Thread.isAlive()的返回值）
  * 线程中断规则：对线程interrupt()方法的调用先行发生于被中断的线程的代码检测到中断事件发生（可以通过Thread.interrupted()方法检测到是否有中断发生
  * 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
  * 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A先行发生于操作C的结论
    注：时间先后顺序与先行发生原则之间基本没有太大关系（衡量并发安全问题不要受到时间顺序干扰，一切必须以先行发生原则为准）
### Java与线程
  并发不一定要依赖多线程（如PHP中很常见的多进程并发）
#### 线程的实现
  线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）
  主流的操作系统都提供了线程实现，Java语言则提供了再不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start()且还未结束的java.lang.Thread类的实例就代表了一个线程
  Thread类与大部分Java API有显著差别，它的所有关键方法都声明为native
  在Java API中，一个Native方法往往以为着这个方法没有使用或无法使用平台无关的手段来实现（也可能为了执行效率使用Native方法，通常最高效率的手段就是平台相关的手段）

  **线程的是实现方式**
  1. 使用内核线程实现
  2. 使用用户线程实现
  3. 使用用户线程加轻量级进程混合实现

  **使用内核线程实现**
  * 内核线程KLT是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并将线程的任务映射到各个处理器上
  * 每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情
  * 支持多线程的内核叫做多线程内核
  * 程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口--轻量级进程LWP
  * 轻量级进程就是通常意义上的线程，每个LWP都由一个内核线程支持，因此只有线支持内核线程，才有轻量级进程
    ![线程模型](D:\local\notes\images\kernel-thread-model.bmp)
    轻量级进程局限性
  1. 基于内核线程实现，各种线程操作，如创建、析构及同步，都需要进行系统调用（系统调用代价较高，需要在用户态和内核态来回切换）
  2. 每个轻量级进程都需要一个内核线程支持，因此轻量级进程要消耗一定内核资源（如内核线程的栈空间），因此一个系统支持的轻量级进程数量有限

  **用户线程实现**
  从广义上讲，一个线程只要不是内核线程，就可以认为是用户线程
  从这个定义上讲，LWP也属于用户线程
  狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现

  用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助（如果程序实现得当，这种线程不需要切换到内核态，因此操作可以非常快速且低消耗，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的）
  ![用户线程模型](D:\local\notes\images\user-thread-model.bmp)

  **用户线程的优势与劣势**
  * 优势：不需要系统内核支援
  * 劣势：没有系统内核的支援，所有线程操作需要用户程序自己处理，线程的创建、切换和调度都需要考虑，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统如何将线程映射到其他处理器上”这类问题解决起来将异常困难，甚至不可能完成（使用用户线程实现的程序一般比较复杂）

  **使用用户线程加轻量级进程混合实现**
  * 用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发
  * 操作系统提供的轻量级进程则作为用户线程和内核线程之间的桥梁
  * 这样可以使用内核提供的线程调度功能及处理器映射，冰企鹅额用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险
  * 许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了用户线程-轻量级进程N:M的线程模型实现
    ![混合模型](D:\local\notes\images\hybrid-model.bmp)

  **Java线程实现**
  Java线程在JDK1.2之前是基于称为“绿色线程”的用户线程实现，在JDK1.2中，线程模型替换为基于操作系统原生线程模型来实现
  操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这在不同平台上没法达成一致，Java虚拟机规范中没有限定Java线程需要使用哪种线程模型实现
  线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是透明的
  注：对Sun JDK来说，它的windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程映射到一条轻量级进程中，因为Windows和Linux系统提供的线程模型都是一对一的

#### Java线程调度
  线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：协同式线程调度和抢占式线程调度

  **协同式线程调度**
  * 线程执行时间由线程本身来控制，线程把自己工作执行完了之后，要主动通知系统切换到另外一个线程上
  * 协同式线程调度的最大好处是实现简单，切换操作对线程自己是可知的，没有线程同步问题
    注：Lua语言中的“协同例程”就是这类实现
  * 协同式线程调度的坏处是线程执行时间不可控制（如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里）

  **抢占式线程调度**
  * 抢占式线程调度，每个线程由系统来分配执行时间，线程切换不有线程本身来决定（Java中，Thread.yield()可以让出执行时间，但是要获取执行时间，线程本身没有什么办法）
  * 这种线程调度方式下，线程执行时间是系统可控的，不会有一个线程导致整个进程阻塞的问题
    注：Java线程调度方式就是抢占式调度

  **Java线程调度**
  虽然Java线程调度是系统自动完成的，但是可以“建议”系统给某些线程多分配一点执行时间，另外一些线程则可以少分配一点--这项操作可以通过设置线程优先级来完成
  Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行
  注：线程优先级不太靠谱（Java线程通过映射到系统原生线程上实现，所以线程调度还是取决于操作系统--虽然很多操作系统都提供线程优先级的概念，但不见得与Java线程优先级一一对应）
  注：比Java线程优先级多的系统好瘦哦，中间留下一点空位；比Java线程优先级少的系统，就不得不出现几个优先级相同的情况
  注：优先级可能会被系统自行改变（Windows系统中存在一个“优先级推进器”的功能，起作用是当系统发现一个线程执行得特别“勤奋努力”的话，可能会越过线程优先级去为它分配执行时间）
  注：不能再程序中通过优先级来完全准确地判断一组状态为Ready的线程会先执行哪一个
#### 状态转换
  Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态
  1. 新建；创建后尚未启动的线程
  2. 运行：Runable包括了操作系统线程状态中的Runing和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间
  3. 无限期等待：处于这种状态的线程不会被分配CPU执行时间，他们要等待被其他线程显示地唤醒--没有设置Timeout参数的Object.wait()；没有设置Timeout参数的Thread.join()方法；LockSupport.park()方法
  4. 限期等待：处于这种状态的线程不会被分配CPU执行时间，不过无须等待被其他线程显示唤醒，在一定时间或它们会由系统自动唤醒--Thread.sleep()方法；设置了Timeout参数的Object.wait()方法；设置了Timeout参数的Thread.join()方法；LockSupport.parkNanos()方法；LockSuport.parkUntil()方法
  5. 阻塞：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁时发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生（在程序等待进入同步区域时，线程将进入这种状态）
  6. 结束：已终止的线程状态，线程已经结束执行

    ![线程状态](D:\local\notes\images\thread-state.bmp)
## 线程安全与锁优化
### 概述
  * 面向过程的编程思想： 软件行业发展初期，程序编写以算法为核心，把数据和过程分别作为独立的部分考虑，数据代表问题空间的客体，程序代码则用于处理这些数据，这种思维方式直接站在计算机的角度去抽象问题和解决问题
  * 面向对象的编程思想：站在现实世界的角度去抽象和解决问题，它把数据和行为都看做是对象的一部分，这样可以让程序员能以符合现实世界的思维方式编写和组织程序
    注：首先需要保证并发的正确性，然后在此基础上实现高效
### 线程安全
  定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的
  这个定义要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用
  注：在大多数场景中，将这个定义弱化，把“调用这个对象的行为”限定为“单次调用”，这个定义的其他描述也能成立的话，就可以称为线程安全了
#### Java语言中的线程安全
  前提：多个线程之间存在共享数据访问
  可以不把线程安全当做一个非真即假的二元排他选项，按照线程安全的“安全程度”由强至弱来排序
  Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立

  **不可变**
  在Java语言中（特指Java内存模型修正后JDK1.5），不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施
  只要一个不可变对象被正确的构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远不会改变，永远不会看到它在多个线程中处于不一致的状态
  不可变带来的安全性是最简单和最纯粹的

  Java语言中，如果共享数据时基本数据类型，那么只要在定义时使用final关键字修饰就可以保证它不可变；如果共享数据是一个对象，就需要保证对象的行为不会对其状态产生任何影响（java.lang.String类的对象，是一个典型的不可变对象--它的substring()、replace()和concat()这些方法都不会影响它原来的值，而是返回一个新构造的字符串对象）

  保证对象行为不影响自己状态的途径:最简单的就是把对象中带状态的变量都声明为final
  在Java API中符合不可变要求的类型，除了String外，常用的还有枚举类型，以及java.lang.Number的部分子类（如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型）
  注：Number的子类型的原子类AutomicInteger和AutomicLong并非不可变

  **绝对线程安全**
  绝对线程安全完全满足严格定义，这通常需要付出很大的，甚至有时候是不切实际的代价
  Java API中标注自己是线程安全的类，大多数都不是绝对线程安全的

  java.util.Vector是一个线程安全的容器，它的add()、get()、size()这类方法都被synchronized修饰，机关这样效率很低，但确实安全，即时它的所有方法都被修饰成同步，也不意味着调用它的时候永远不需要同步手段了

  **相对线程安全**
  相对线程安全就是我们通常意义上讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，在调用时不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性
  注：在Java语言中，大部分线程安全类都属于这种类型（如Vector、HashTable、Collections的sychronizedCollection()方法包装的集合等）

  **线程兼容**
  线程兼容指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，平常说一个类不是线程安全的，绝大多数时候是指这一种情况
  Java API中大部分类都是属于线程兼容的，如ArrayList和HashMap等

  **线程对立**
  线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码
  由于Java语言天生具备多线程特性，线程对立这种排斥多线程的代码很少出现，而且通常有害，应该尽量避免
  例：Thread类的suspend()和resume()方法，如果两个线程同时持有一个线程对象，一个尝试去终端线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都存在死锁风险（如果suspend()中断的线程就是即将执行resume()的那个线程，那就肯定要产生死锁）
  注：suspend()方法和resume()方法已经被JDK声明废弃了
  注：常见的线程对立操作还有System.SetIn()、System.setOut和System.runFinalizersOnExit()等

#### 线程安全的实现方法
  代码编写如何实现线程安全；虚拟机如何实现同步与锁

  **互斥同步**
  同步是指多个线程并发访问数据时，保证共享数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用
  互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现有段
  互斥是因，同步是果；互斥是方法，同步是目的

  在Java中，最基本的互斥同步手段是synchronized关键字，这个关键字经过编译后，会在同步块前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象
  如果Java程序中sychronized明确指明了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象
  根据虚拟机规范的要求，在执行monitorenter指令是，首先尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，指到独享锁被另外一个线程释放为止
  注：虚拟机规范中，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题；同步块在已进入的线程执行完之前，会阻塞后面其他线程进入
  注：Java的线程是映射到操作系统的原生线程上的，如果要阻塞或唤醒一个线程，都需要操作系统帮忙完成，这就需要从用户态换到核心态，因此状态转换需要耗费很多处理器时间
  注：对于代码简单的同步块（如synchronized修饰的getter()或setter()方法）状态转换消耗的时间可能比用户代码执行的时间还长，synchronized是Java语言中一个重量级操作
  注：synchronized关键字必要时使用，虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态

  除了synchronized之外，还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步
  ReentrantLocck与synchronized异同
  同：都具备线程重入特性
  异：代码写法上优点区别，一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。ReentrantLock增加了一些高级功能，主要由以下3项：等待可中断、可实现公平锁、以及锁可以绑定多个条件
  **等待可中断**
  等待可中断指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对于处理执行时间长的同步块很有帮助
  **公平锁**
  公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁，synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔的改造函数要求使用公平锁
  **锁绑定多个条件**
  锁绑定多个条件是指一个ReentratnLock对象可以同时绑定多个条件对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个条件关联时，就不得不额外地添加一个锁，而ReentrantLock则无须这样，只需要多次调用newCondition()方法即可
  注：提倡在synchronized能实现需求的情况下，有限考虑使用synchronized来进行同步

  **非阻塞同步**
  互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步
  从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作
  随着硬件指令集的发展，有了另外一个选择：基于冲突检测的乐观并发策略

  **基于冲突检测的乐观并发策略**
  先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果有共享数据争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步
  需要保证操作和冲突检测这两个步骤具备原子性（如果再使用互斥同步来保证就失去了意义，所以只能靠硬件来完成--硬件保证一个语义看起来需要很多次操作的行为只通过一条处理器指令就能完成）
  * 测试并设置
  * 获取并增加
  * 交换
    注：前3条20世纪就已经存在于大多数指令集之中的处理器指令
  * 比较并交换
  * 加载链接/条件存储
    注：后两条是现代处理器新增的

  **CAS**
  CAS指令需要有3个操作数，分别是内存位置（在Java中可以理解为变量内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）
  CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但无论是否更新V的值，都会返回V的旧值，这是原子操作
  注：JDK1.5后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用过程，或者可以认为无条件内联进去
  注：由于Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有使用启动类加载器加载的Class才能访问它），如果不采用反射手段，只能通过其他Java API间接使用它，比如JUC包中的整数原子类，其中的compareAndSet()和getAndIncrement()等方法有使用了Unsafe类的CAS操作
  注：CAS无法涵盖互斥同步的所有场景；CAS语义是哪个不完美（如果一个变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然为A，这不能说明它的中没被其他线程改变过，这个逻辑漏洞称为CAS操作的“ABA"问题）
  注：JUC包为了解决这个问题，提供了一个带标记的原子引用类AtomicStampedReference，可以通过控制变量值的版本来保证CAS正确性（比较鸡肋，大部分情况ABA问题不会影响程序并发正确性，如果需要解决ABA问题，改用传统互斥同步比原子类更高效）

  **无同步方案**
  同步只是保证共享数据争用时的正确性手段，保证线程安全，并不一定要进行同步（一个方法不涉及共享数据，因此有一些代码天生线程安全）
  可重入代码：这种代码也叫做纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是基本特性，它可以保证线程安全，即所有可重入的代码都是线程安全的，但并非所有线程安全的代码都是可重入的
  可重入代码特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等
  判断代码可重入性规则：如果一个方法、它的返回结果可以预测，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，也就是线程安全的

  **线程本地存储**
  如果一段代码所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在一个线程中执行，如果能保证，就可以把共享数据的可见范围限制在同一个线程内，这样，无须同步也能保证线程间不出现数据争用的问题
  大部分使用消费队列的架构模式（如生产者-消费者模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”的处理方式
  注：如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，可以通过java.lang.ThreadLocal类实现线程本地存储的功能（每个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地变量为值的K-V值对）
  注：被虚拟机特殊处理的函数称为固有函数，类似的固有函数还有Math.sin()等
### 锁优化
  高效并发是JDK1.5到JDK1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费大量精力实现各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等（更高效地线程间共享数据，解决竞争问题，提高程序执行效率）
#### 自旋锁与适应性自旋
  互斥同步中挂起线程和恢复线程的操作都需要转入内核态中完成，如果共享数据锁定状态只会持续很短时间，为这段时间挂起和恢复线程不值得
  自旋锁：让后面请求锁的线程“稍等一会”，但不放弃处理区执行时间，只需让线程执行一个忙循环（自旋）
  自旋锁在JDK1.4.2中引入，但默认关闭，可以使用-XX:+UseSpinning参数开启，在JDK1.6中默认开启
  注：自旋等待虽然避免了线程切换开销但是要占用处理器时间，如果锁占用时间长，那么自旋线程只会白白消耗处理器资源，而不会做任何有用工作，因此自旋等待时间必须要有一定限度
  注：自旋次数默认值是10次，可以使用参数-XX:PreBlockSpin
  
  在JDK1.6中引入了自适应的自旋锁。自适应意味着自旋时间不再固定，而是由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定（同一个锁对象，如果自旋成功获得过锁，将允许自旋等待持续相对更长时间；如果自旋很少成功获得，可能忽略自旋过程，以避免浪费处理器资源）
#### 锁消除
  锁消除是指虚拟机即时编译器运行时，对一些代码要求同步，但是检测到不可能存在共享数据竞争的锁进行消除
  锁消除的主要判定依据来源于逃逸分析的数据支持（虚拟机数据流分析）
  如果判断在一段代码中，堆上所有数据都不会逃逸出去从而被其他线程访问到，就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然无须进行
  注：在JDK1.5之前字符串连接会转化为StringBuffer对象的连续append()操作，在JDK1.5及以后的版本，会转化为StringBuilder对象的连续append()操作
  注：许多同步措施不是程序员自己加入的
#### 锁粗化
  原则上，编写代码时，推荐同步块作用范围限制尽量小--只在共享数据实际作用域中进行同步（为了使需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁）
  大部分情况下，上面原则是正确的，但是一些列连续操作都对同一对象反复加锁和解锁，甚至加锁操作出现在循环体中，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗
  如果虚拟机探测到有这样一串零碎操作对同一个对象加锁，会把加锁同步范围扩展（粗化）到整个操作序列外部
#### 轻量级锁
  轻量级锁是JDK1.6中加入的新型锁机制，这个轻量级是相对于使用操作系统互斥量来实现的传统锁而言，因此传统锁机制称为重量级锁
  注：轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗
  
  **HotSpot虚拟机的独享（对象头部分）的内存布局**
  HotSpot虚拟机的对象头
  1. 用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，这部分数据长度在32位和64位的虚拟机中分别为32bit和64bit，称为Mark Word，它是实现轻量级锁和偏向锁的关键
  2. 用于存储指向方法区类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度
  对象头信息与对象自身定义的数据无关的额外存储成本（考虑到虚拟机的空间效率，Mark Word被设计为一个非固定的数据结构以便在极小的空间存储尽量多的信息，它会根据对象的状态复用自己的存储空间）
  32位HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下的对象的存储内容
  ![对象头](D:\local\notes\images\)D:\local\notes\images\object-header.bmp)
  
  **轻量级锁执行过程**
  1. 当代码进入同步块时，如果同步对象没有被锁定，虚拟机首先将在当前线程栈帧中建立一个名为锁记录的空间，用于存储对象目前的Mark Word的拷贝，此时线程堆栈与对象头状态![执行过程1](D:\local\notes\images\lightweight-lock-process1.bmp)
  2. 虚拟机使用CAS操作尝试将对象的Mark Word更新为指向Lock Record指针，如果更新成功，那么这个线程就拥有了该对象的轻量级锁，此时线程堆栈与对象头的状态![执行过程2](D:\local\notes\images\lightweight-lock-process2.bmp)
  3. 如果更新操作失败，虚拟机首先会检查对象的Mark Word是否当前线程栈帧，如果是说明当前线程已经拥有了这个对象的锁，就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁不再有效，要膨胀为重量级锁，Mark Word中储存的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态
  注：轻量级锁的解锁过程也是通过CAS操作进行的，如果对象的Mark Word仍然指向线程锁记录，那就使用CAS操作把对象当前Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了；如果替换失败，说明有其他线程尝试过获取该锁那就要在释放锁的同时，唤醒被挂起的线程
  注：轻量级锁能提升程序同步性能的依据是“对于绝大部分锁，整个同步周期内都是不存在竞争的”
  注：在竞争情况下，额外发生了CAS操作，轻量级锁会比传统重量级锁更慢
#### 偏向锁
  偏向锁也是JDK1.6引入的一项锁优化
  目的：消除数据在无竞争情况下的同步原语，进一步提高程序运行性能
  如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争情况下把整个同步都消除掉，连CAS都不做了
  偏向锁会偏向第一个获得它的线程，如果在接下来的指向性过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步
  虚拟机使用参数-XX:+UseBiasedLocking启用偏向锁，当锁对象第一次被线程获取时，虚拟机将会进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果CAS成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机可不再进行任何同步操作（例如Locking、Unlocking以及Mark Word的Update等）
  当另外一个线程尝试获取这个锁时，偏向模式宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁状态，后续的同步操作就如轻量级锁那样执行
  ![偏向锁、轻量级锁的状态转化及对象Mark Word关系图](D:\local\notes\images\lock-relation.bmp)
  注：偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡性质的优化，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的
  